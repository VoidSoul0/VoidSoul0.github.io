<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.ico">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <meta http-equiv="Cache-Control" content="no-transform">
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="baidu-site-verification" content="pdp4HsKo9i">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="//cdn.bootcdn.net/ajax/libs/font-awesome/5.13.1/css/all.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"voidsoul0.github.io","root":"/","scheme":"Gemini","version":"8.0.0-rc.4","exturl":true,"sidebar":{"position":"left","width":220,"display":"post","padding":18,"offset":12},"copycode":true,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":false,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Java入门很久了，也没有好好整理一下知识树，遇到一些忘记or遗漏的知识点时，就会深感自身能力不足且惭愧，所以借此机会将Java的基础知识结构过一遍">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础整理与查漏补缺">
<meta property="og:url" content="https://voidsoul0.github.io/java/java-base/index.html">
<meta property="og:site_name" content="Lv.0">
<meta property="og:description" content="Java入门很久了，也没有好好整理一下知识树，遇到一些忘记or遗漏的知识点时，就会深感自身能力不足且惭愧，所以借此机会将Java的基础知识结构过一遍">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://voidsoul0.github.io/java/java-base/Java%E5%9F%BA%E7%A1%80.png">
<meta property="og:image" content="https://voidsoul0.github.io/java/java-base/image-20210319024525292.png">
<meta property="og:image" content="https://voidsoul0.github.io/java/java-base/image-20210319233851493.png">
<meta property="og:image" content="https://voidsoul0.github.io/java/java-base/image-20210320032317279.png">
<meta property="og:image" content="https://voidsoul0.github.io/java/java-base/image-20210323232401844.png">
<meta property="og:image" content="https://voidsoul0.github.io/java/java-base/image-20210323232754938.png">
<meta property="og:image" content="https://voidsoul0.github.io/java/java-base/image-20210321234418184.png">
<meta property="og:image" content="https://voidsoul0.github.io/java/java-base/image-20210408163038589.png">
<meta property="og:image" content="https://voidsoul0.github.io/java/java-base/image-20210325222315531.png">
<meta property="og:image" content="https://voidsoul0.github.io/java/java-base/image-20210327235754443.png">
<meta property="og:image" content="https://voidsoul0.github.io/java/java-base/image-20210328194831344.png">
<meta property="og:image" content="https://voidsoul0.github.io/java/java-base/image-20210329012311006.png">
<meta property="og:image" content="https://voidsoul0.github.io/java/java-base/image-20210329224849408.png">
<meta property="og:image" content="https://voidsoul0.github.io/java/java-base/CharSequence.jpg">
<meta property="og:image" content="https://voidsoul0.github.io/java/java-base/image-20210401232451010.png">
<meta property="og:image" content="https://voidsoul0.github.io/java/java-base/Number.png">
<meta property="og:image" content="https://voidsoul0.github.io/java/java-base/image-20210402172925472.png">
<meta property="og:image" content="https://voidsoul0.github.io/java/java-base/image-20210403165857438.png">
<meta property="og:image" content="https://voidsoul0.github.io/java/java-base/image-20210403182658582.png">
<meta property="og:image" content="https://voidsoul0.github.io/java/java-base/image-20210404172932597.png">
<meta property="og:image" content="https://voidsoul0.github.io/java/java-base/image-20210404174152009.png">
<meta property="og:image" content="https://voidsoul0.github.io/java/java-base/image-20210404231257646.png">
<meta property="og:image" content="https://voidsoul0.github.io/java/java-base/image-20210405004318655.png">
<meta property="og:image" content="https://voidsoul0.github.io/java/java-base/image-20210405022202184.png">
<meta property="og:image" content="https://voidsoul0.github.io/java/java-base/image-20210405172114387.png">
<meta property="og:image" content="https://voidsoul0.github.io/java/java-base/image-20210406164009530.png">
<meta property="og:image" content="https://voidsoul0.github.io/java/java-base/image-20210406203401607.png">
<meta property="og:image" content="https://voidsoul0.github.io/java/java-base/image-20210406233315537.png">
<meta property="og:image" content="https://voidsoul0.github.io/java/java-base/image-20210407000024041.png">
<meta property="og:image" content="https://voidsoul0.github.io/java/java-base/image-20210407232425816.png">
<meta property="og:image" content="https://voidsoul0.github.io/java/java-base/image-20210409195044213.png">
<meta property="og:image" content="https://voidsoul0.github.io/java/java-base/image-20210410172020926.png">
<meta property="og:image" content="https://voidsoul0.github.io/java/java-base/image-20210411025947381.png">
<meta property="article:published_time" content="2021-04-11T08:00:00.000Z">
<meta property="article:modified_time" content="2021-04-15T07:00:00.000Z">
<meta property="article:author" content="VoidSoul">
<meta property="article:tag" content="java">
<meta property="article:tag" content="spring">
<meta property="article:tag" content="springMVC">
<meta property="article:tag" content="springboot">
<meta property="article:tag" content="mybatis">
<meta property="article:tag" content="shiro">
<meta property="article:tag" content="linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://voidsoul0.github.io/java/java-base/Java%E5%9F%BA%E7%A1%80.png">

<link rel="canonical" href="https://voidsoul0.github.io/java/java-base/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java基础整理与查漏补缺 | Lv.0</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container">
    <div class="headband"></div>

    <main class="main">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader">
        <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line toggle-line-first"></span>
        <span class="toggle-line toggle-line-middle"></span>
        <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Lv.0</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">talk is cheap, show me the code</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#介绍"><span class="nav-text">介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#发展历史"><span class="nav-text">发展历史</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#语言特点"><span class="nav-text">语言特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JRE、JDK与JVM"><span class="nav-text">JRE、JDK与JVM</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#开发工具与环境"><span class="nav-text">开发工具与环境</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#环境变量"><span class="nav-text">环境变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#IDE"><span class="nav-text">IDE</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#彩蛋"><span class="nav-text">彩蛋</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#基本语法"><span class="nav-text">基本语法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#标识符"><span class="nav-text">标识符</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#关键字"><span class="nav-text">关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#修饰符"><span class="nav-text">修饰符</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#修饰符的访问范围"><span class="nav-text">修饰符的访问范围</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#注释"><span class="nav-text">注释</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#文档注释"><span class="nav-text">文档注释</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#变量"><span class="nav-text">变量</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#局部变量"><span class="nav-text">局部变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#实例变量"><span class="nav-text">实例变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#静态变量"><span class="nav-text">静态变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#变量的作用域"><span class="nav-text">变量的作用域</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#常量"><span class="nav-text">常量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#运算符"><span class="nav-text">运算符</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#运算符优先级"><span class="nav-text">运算符优先级</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本数据类型"><span class="nav-text">基本数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#范围"><span class="nav-text">范围</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类型转换"><span class="nav-text">类型转换</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#自动类型转换"><span class="nav-text">自动类型转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#强制类型转换"><span class="nav-text">强制类型转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#隐含强制类型转换"><span class="nav-text">隐含强制类型转换</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#流程控制"><span class="nav-text">流程控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组"><span class="nav-text">数组</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#多维数组"><span class="nav-text">多维数组</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#基本输入与输出"><span class="nav-text">基本输入与输出</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#编程规范"><span class="nav-text">编程规范</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#面向对象"><span class="nav-text">面向对象</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#特征"><span class="nav-text">特征</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#类"><span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#字段-属性"><span class="nav-text">字段(属性)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#抽象类"><span class="nav-text">抽象类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接口"><span class="nav-text">接口</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#比较接口与抽象类"><span class="nav-text">比较接口与抽象类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#嵌套类"><span class="nav-text">嵌套类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#内部类"><span class="nav-text">内部类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#静态内部类"><span class="nav-text">静态内部类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#局部类"><span class="nav-text">局部类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#匿名类"><span class="nav-text">匿名类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#枚举"><span class="nav-text">枚举</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#对象-实例"><span class="nav-text">对象(实例)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法"><span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#方法的参数"><span class="nav-text">方法的参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#构造方法"><span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#静态方法"><span class="nav-text">静态方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法重载"><span class="nav-text">方法重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#方法重写-覆写"><span class="nav-text">方法重写(覆写)</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#被隐藏的方法"><span class="nav-text">被隐藏的方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#接口方法"><span class="nav-text">接口方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#默认方法"><span class="nav-text">默认方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#接口的静态方法"><span class="nav-text">接口的静态方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#抽象方法"><span class="nav-text">抽象方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#包及类的访问作用域"><span class="nav-text">包及类的访问作用域</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常用核心类"><span class="nav-text">常用核心类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#字符串String"><span class="nav-text">字符串String</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#StringBuffer"><span class="nav-text">StringBuffer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#StringBuilder"><span class="nav-text">StringBuilder</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#StringJoiner"><span class="nav-text">StringJoiner</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#引用类型-包装类"><span class="nav-text">引用类型(包装类)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#自动装箱-amp-拆箱"><span class="nav-text">自动装箱&amp;拆箱</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#整数缓存机制"><span class="nav-text">整数缓存机制</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数学计算"><span class="nav-text">数学计算</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Math"><span class="nav-text">Math</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Random"><span class="nav-text">Random</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BigInteger"><span class="nav-text">BigInteger</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BigDecimal"><span class="nav-text">BigDecimal</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#时间与日期"><span class="nav-text">时间与日期</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#常量-1"><span class="nav-text">常量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#本地日期"><span class="nav-text">本地日期</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#本地时间"><span class="nav-text">本地时间</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#时区和偏移"><span class="nav-text">时区和偏移</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#时刻与间隔"><span class="nav-text">时刻与间隔</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#格式化"><span class="nav-text">格式化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#数组处理Arrays"><span class="nav-text">数组处理Arrays</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#其它"><span class="nav-text">其它</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Optional"><span class="nav-text">Optional</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#UUID"><span class="nav-text">UUID</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Base64"><span class="nav-text">Base64</span></a></li></ol></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="VoidSoul"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">VoidSoul</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">25</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cDovL3dwYS5xcS5jb20vbXNncmQ/dj0zJnVpbj0zNjAzMDE1MjQmc2l0ZT1xcSZtZW51PXllcw==" title="QQ → http:&#x2F;&#x2F;wpa.qq.com&#x2F;msgrd?v&#x3D;3&amp;uin&#x3D;360301524&amp;site&#x3D;qq&amp;menu&#x3D;yes"><i class="fab fa-qq fa-fw"></i></span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL1ZvaWRTb3VsMA==" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;VoidSoul0"><i class="fab fa-github fa-fw"></i></span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOjM2MDMwMTUyNEBxcS5jb20=" title="E-Mail → mailto:360301524@qq.com"><i class="fa fa-envelope fa-fw"></i></span>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></span>
  </div>



      </section>
    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </header>

      
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div id="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


      <div class="main-inner">
        

        <div class="content post posts-expand">
          

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://voidsoul0.github.io/java/java-base/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="VoidSoul">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lv.0">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java基础整理与查漏补缺
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-11 16:00:00" itemprop="dateCreated datePublished" datetime="2021-04-11T16:00:00+08:00">2021-04-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-15 15:00:00" itemprop="dateModified" datetime="2021-04-15T15:00:00+08:00">2021-04-15</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
                </span>
            </span>

          
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/java/java-base/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/java/java-base/" itemprop="commentCount"></span>
    </a>
  </span>
  
  
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
              <span>27k</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><font color=white>Java入门很久了，也没有好好整理一下知识树，遇到一些忘记or遗漏的知识点时，就会深感自身能力不足且惭愧，所以借此机会将Java的基础知识结构过一遍</font></p>
<a id="more"></a>

<p>首先是<span class="exturl" data-url="aHR0cDovL25hb3R1LmJhaWR1LmNvbS9maWxlLzhkMjQyMGQyYjUyNGVlOWZmMDY1NjllZWJkNjhjMTAyP3Rva2VuPTczMmY2MGY5MDNiZDM4ZDM=">思维导图<i class="fa fa-external-link-alt"></i></span>：</p>
<p><img src="Java%E5%9F%BA%E7%A1%80.png" alt="Java基础"></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote>
<p>Java是一种广泛使用的计算机编程语言，拥有跨平台、面向对象、泛型编程的特性，广泛应用于企业级Web应用开发和移动应用开发。</p>
</blockquote>
<p>Java的发展依托于互联网，所以绝大多数企业级Web应用开发都是以Java作为开发语言，而移动应用开发则是因为移动设备的Android系统的大部分代码采用Java编程语言编程</p>
<h3 id="发展历史"><a href="#发展历史" class="headerlink" title="发展历史"></a>发展历史</h3><p>上世纪90年代初，任职于Sun MicroSystems的詹姆斯·高斯林（James Gosling，公认的Java之父）等人开发了Java语言的雏形，最初被命名为Oak（橡树）。随着1990年代互联网的发展，Sun公司看见Oak在互联网上应用的前景，于是改造了Oak，直到1995年5月以Java的名称正式发布（当时Oak这个名字已被一家显卡制造商注册）。Java伴随着互联网的迅猛发展而发展，逐渐成为重要的编程语言之一。</p>
<p>1999年6月，Sun公司发布了Java的三个版本：微型版（J2ME）、标准版（J2SE）和企业版（J2EE）。</p>
<p>2004年9月，J2SE1.5发布，为了表示该版本的重要性，版本号1.5改为5.0，此后的版本号均以X.0命名。</p>
<p>2005年6月，<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvSmF2YU9uZSVFNSVBNCVBNyVFNCVCQyU5QQ==">JavaOne大会<i class="fa fa-external-link-alt"></i></span>召开，Sun公司发布Java SE 6。此时，为了取消Java各种版本名中的数字<code>2</code>：J2EE更名为Java EE，J2SE更名为Java SE，J2ME更名为Java ME。</p>
<p>2009年4月，Oracle公司（甲骨文）以74亿美金收购了Sun公司，Java也随之成为了甲骨文公司的产品。</p>
<h3 id="语言特点"><a href="#语言特点" class="headerlink" title="语言特点"></a>语言特点</h3><ol>
<li><p>跨平台，Java对于不同的硬件架构和操作系统（Windows、Linux、macOS）等，提供了不同的本地语言环境，这使得开发者或用户不会因为不同平台的差异而在开发或使用过程中产生隔阂。</p>
<blockquote>
<p>Java不同于一般的编译语言或解释型语言。它首先将源代码编译成字节码，再依赖各种不同平台上的虚拟机来解释执行字节码，从而具有“一次编写，到处运行”的跨平台特性。在早期JVM中，这在一定程度上降低了Java程序的运行效率。但在J2SE1.4.2之后，Java的运行速度有了大幅提升。</p>
</blockquote>
</li>
<li><p>面向对象编程（即Object-oriented programming，缩写OOP，又叫物件导向程式设计）：Java语言的开发者在设计软件的时候将一切事物视作对象进行处理，事物的属性即对象的字段，事物的行为即对象的方法。（作为对比：C语言则是面向过程编程）</p>
</li>
<li><p>泛型（也叫参数化类型）编程允许程序员在强类型程序设计语言中编写代码时使用一些调用时才指定的类型，在实例化时作为参数指明这些类型，使用泛型的主要目的是加强类型安全及减少类型转换的次数。</p>
</li>
<li><p>自动垃圾回收：Java对象的创建和放置都是在内存堆栈上面进行的。当一个对象没有任何引用的时候，Java的自动垃圾收集机制就会发挥作用，自动删除这个对象所占用的空间，释放内存以避免内存泄漏。</p>
</li>
<li><p>解释型：Java程序在Java平台上被编译为字节码格式，然后可以在实现这个Java平台的任何系统中运行。在运行时，Java平台中的Java解释器对这些字节码进行解释执行。</p>
</li>
</ol>
<p>此外java特点还有分布式的、健壮的、安全的、可移植的、多线程的、动态的、高性能的……</p>
<h3 id="JRE、JDK与JVM"><a href="#JRE、JDK与JVM" class="headerlink" title="JRE、JDK与JVM"></a>JRE、JDK与JVM</h3><p>JVM：Java Virtual Machine，即java虚拟机，能够运行编译成java字节码形式的应用程序</p>
<blockquote>
<p>Java虚拟机有自己完善的硬体架构，如处理器、堆栈、寄存器等，还具有相应的指令系统。JVM屏蔽了与具体操作系统平台相关的信息，使得Java程序只需生成在Java虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。通过对中央处理器（CPU）所执行的软件实现，实现能执行编译过的Java程序码（Applet与应用程序）。</p>
</blockquote>
<p>JRE：Java Runtime Environment，java运行环境，包括了java虚拟机以及运行库，要运行java程序就需要安装JRE</p>
<p>JDK：Java Development Kit，java开发工具包，除了包含有JRE以外，还有开发者所需的如编译、调试工具等等</p>
<p>关于三者的关系以及包含的组件，参考如下JavaSE概念图：</p>
<p><img src="image-20210319024525292.png" alt="image-20210319024525292"></p>
<h3 id="开发工具与环境"><a href="#开发工具与环境" class="headerlink" title="开发工具与环境"></a>开发工具与环境</h3><p>搭建Java开发环境要先安装JDK，此处参考<a href="/software/portable-software/#Oracle-JDK">JDK8便携版的制作</a>，或者JDK11（有Oracle官方提供的zip版本），需要注意的是JDK11没有自带JRE，需要在JDK根目录使用如下命令生成：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin\jlink.exe --module-path jmods --add-modules java.desktop --output jre</span><br></pre></td></tr></table></figure>

<p>若不愿在Oracle注册帐号，还可以通过以下途径进行下载：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuaW5qZGsuY24v">Java I tell you<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9wb3J0YXBwcy5pby9hcHAvb3JhY2xlLWpkay1wb3J0YWJsZS8=">Portapps<i class="fa fa-external-link-alt"></i></span>（仅OracleJDK）</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9taXJyb3JzLnR1bmEudHNpbmdodWEuZWR1LmNuL0Fkb3B0T3BlbkpESy8=">清华大学开源软件镜像站<i class="fa fa-external-link-alt"></i></span>（仅OpenJDK）</li>
</ul>
<h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><p>在环境变量（当前用户为管理员的话，在用户变量或系统变量中均可）新建<code>JAVA_HOME</code>，值指向JDK的安装目录，然后在PATH中追加<code>%JAVA_HOME%\bin;%JAVA_HOME%\jre\bin</code>，与其它值之间使用分号分割，末尾不用分号</p>
<p>以前的教程中还会提到设置<code>CLASSPATH</code>，需要注意的是在JDK5以后不需要再另外设置<code>CLASSPATH</code>了。参考<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlLzgvZG9jcy90ZWNobm90ZXMvdG9vbHMvd2luZG93cy9jbGFzc3BhdGguaHRtbA==">Setting the Class Path<i class="fa fa-external-link-alt"></i></span>以及<span class="exturl" data-url="aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvMTI1MjU5OTU0ODM0Mzc0NC8xMjYwNDY2OTE0MzM5Mjk2">classpath和jar<i class="fa fa-external-link-alt"></i></span></p>
<blockquote>
<p>类路径告诉JDK工具和应用程序在哪里可以找到<strong>第三方和用户定义的类</strong>，这些类不是Java平台的扩展或组成部分。</p>
</blockquote>
<h4 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h4><p>尽管可以使用记事本写代码并使用命令来编译运行，但还是不如专门的集成开发工具便捷。<br>主流的java开发工具：</p>
<ul>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuZWNsaXBzZS5vcmcv">Eclipse<i class="fa fa-external-link-alt"></i></span>：最初是由IBM公司开发的，2001年11月贡献给开源社区，由非营利软件供应商联盟Eclipse基金会管理。早期使用的比较多。优点是免费、开源且轻量</li>
<li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamV0YnJhaW5zLmNvbS9pZGVhLw==">IDEA<i class="fa fa-external-link-alt"></i></span>：JetBrains公司开发，功能强大且十分智能，编码体验很舒适。仅社区版免费但没有数据库工具、不支持Spring开发等等，旗舰版可试用30天。有官方汉化插件，比eclipse占用更多内存，更新稳定但BUG也不少，推出新特性的同时也会有新BUG出现</li>
<li><span class="exturl" data-url="aHR0cHM6Ly9jb2RlLnZpc3VhbHN0dWRpby5jb20v">VScode<i class="fa fa-external-link-alt"></i></span>：由微软开发，和那个臃肿的Visual Studio没啥关系。严格来说不是IDE，而是功能强大的编辑器，IDE能做到的，它也能做到。丰富的插件市场使它可以胜任一切编程语言</li>
</ul>
<h4 id="彩蛋"><a href="#彩蛋" class="headerlink" title="彩蛋"></a>彩蛋</h4><p>使用十六进制编辑器打开由Java源代码编译出的二进制文件（.class文件）的话，最前面的4个字节是CA FE BA BE，即词组“CAFE BABE”（咖啡屋宝贝）。</p>
<p><img src="image-20210319233851493.png" alt="image-20210319233851493"></p>
<h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><p>无论什么编程语言，先从一段Hello World代码开始：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Hello World"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>public/class/static/void：都是关键字，其中public为访问修饰符，class表示这是一个类，static表示是静态的，void表示返回类型为空（没有返回值）</li>
<li>Main/main；作为标识符，M大写的表示类名，这个名字必须与文件名一致，每个java源文件有且只能有一个公共类；小写的则是方法名，作为应用程序的入口点。<strong>在Java编程语言中，每个应用程序都必须包含一个main方法</strong></li>
<li>String[] args：用于传递命令行参数</li>
</ul>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>标识符是指用于命名类名、变量名以及方法名的字符，它有以下几点要求：</p>
<ul>
<li>必须以字母（大写或小写）,美元符号<code>$</code>、或者下划线<code>_</code>开始</li>
<li>之后可以是字母（大写或小写）,美元符号<code>$</code>、下划线<code>_</code>或数字的任意组合</li>
<li>不能使用关键字作为标识符</li>
<li>大小写敏感</li>
</ul>
<blockquote>
<p><strong>不要使用中文作为标识符</strong>，尽管这在编译和运行过程中是正常的</p>
</blockquote>
<h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><table>
<thead>
<tr>
<th align="center">类别</th>
<th align="center">关键字</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">访问控制</td>
<td align="center">private</td>
<td align="center">私有的</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">protected</td>
<td align="center">受保护的</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">public</td>
<td align="center">公共的</td>
</tr>
<tr>
<td align="center">类、方法和变量修饰符</td>
<td align="center">abstract</td>
<td align="center">抽象的（类）</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">class</td>
<td align="center">类</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">extends</td>
<td align="center">扩充、继承</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">final</td>
<td align="center">最终的、不可变的</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">implements</td>
<td align="center">实现（接口）</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">interface</td>
<td align="center">接口</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">native</td>
<td align="center">本地，原生方法（非Java实现）</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">new</td>
<td align="center">新、创建</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">static</td>
<td align="center">静态</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">strictfp</td>
<td align="center">严格、精准</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">synchronized</td>
<td align="center">（线程）同步</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">transient</td>
<td align="center">短暂</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">volatile</td>
<td align="center">易失</td>
</tr>
<tr>
<td align="center">程序控制语句</td>
<td align="center">braek</td>
<td align="center">跳出（循环）</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">case</td>
<td align="center">定义一个值以供switch选择</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">continue</td>
<td align="center">继续</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">default</td>
<td align="center">默认</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">do</td>
<td align="center">做（循环）</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">else</td>
<td align="center">否则</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">for</td>
<td align="center">循环</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">if</td>
<td align="center">如果</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">instanceof</td>
<td align="center">（是否是对象的）实例</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">return</td>
<td align="center">返回</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">switch</td>
<td align="center">根据值选择执行</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">while</td>
<td align="center">循环</td>
</tr>
<tr>
<td align="center">错误处理</td>
<td align="center">assert</td>
<td align="center">断言</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">catch</td>
<td align="center">处理捕获（的异常）</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">finally</td>
<td align="center">有没有异常都执行</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">throw</td>
<td align="center">抛出异常</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">throws</td>
<td align="center">声明可能被抛出的异常</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">try</td>
<td align="center">捕获（异常）</td>
</tr>
<tr>
<td align="center">包相关</td>
<td align="center">import</td>
<td align="center">导入</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">package</td>
<td align="center">包（的路径）</td>
</tr>
<tr>
<td align="center">基本类型</td>
<td align="center">boolean</td>
<td align="center">布尔</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">byte</td>
<td align="center">字节</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">char</td>
<td align="center">字符</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">double</td>
<td align="center">双精度浮点</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">float</td>
<td align="center">单精度浮点</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">int</td>
<td align="center">整型</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">long</td>
<td align="center">长整型</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">short</td>
<td align="center">短整型</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">null</td>
<td align="center">空</td>
</tr>
<tr>
<td align="center">变量引用</td>
<td align="center">super</td>
<td align="center">父类、超类</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">this</td>
<td align="center">本类</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">void</td>
<td align="center">无返回值</td>
</tr>
<tr>
<td align="center">保留</td>
<td align="center">goto</td>
<td align="center">跳转，不可使用</td>
</tr>
<tr>
<td align="center"></td>
<td align="center">const</td>
<td align="center">常量，不可使用</td>
</tr>
</tbody></table>
<h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><p>不写修饰符即为package/friendly/default。</p>
<ul>
<li><p>package：在同一包内可见。可修饰：类、接口、变量、方法</p>
</li>
<li><p>private：在同一类内可见。可修饰：变量、方法。 不能修饰类（外部类）</p>
</li>
<li><p>public：对所有类可见。可修饰：类、接口、变量、方法</p>
</li>
<li><p>protected：对同一包内的类和所有子类可见。可修饰：变量、方法。 不能修饰类（外部类）</p>
</li>
</ul>
<h5 id="修饰符的访问范围"><a href="#修饰符的访问范围" class="headerlink" title="修饰符的访问范围"></a>修饰符的访问范围</h5><p><img src="image-20210320032317279.png" alt="image-20210320032317279"></p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><blockquote>
<p>注释的作用：标识程序是干什么的，以及它是如何构建的。注释帮助程序员进行相互沟通以及理解程序。注释不是程序设计语言，所以编译器编译程序时忽略它们。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 单行注释</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">多行注释</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h4 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h4><p>还有一种特殊的注释叫<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlLzgvZG9jcy90ZWNobm90ZXMvdG9vbHMvd2luZG93cy9qYXZhZG9jLmh0bWw=">JavaDoc<i class="fa fa-external-link-alt"></i></span>，它允许你在程序中嵌入关于程序的信息，这种特殊的多行注释需要写在类或方法的定义处，用于从Java源文件生成API文档的HTML页面。格式如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<p>文档注释内可以使用两种标签，一种是仅放置于描述部分后面的块标签（Block tags）：</p>
<ul>
<li>@author：作者名</li>
<li>@deprecated：已弃用的类、方法或属性</li>
<li>@throws和@exception：抛出的异常</li>
<li>@param：方法的参数</li>
<li>@return：方法的返回值</li>
<li>@version：版本号</li>
<li>@since：起始的JDK版本号（基于什么版本开发的）</li>
<li>@see：指定到其它类的链接（另请参阅）</li>
<li>@serial：用于默认可序列化字段（参考<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlLzgvZG9jcy90ZWNobm90ZXMvZ3VpZGVzL3NlcmlhbGl6YXRpb24vaW5kZXguaHRtbA==">Java对象序列化<i class="fa fa-external-link-alt"></i></span>）</li>
<li>@implNote：实现说明</li>
</ul>
<p>另一种是可以放置在注释的描述部分或任意位置的内联标签（Inline tags）：</p>
<ul>
<li>{@docRoot}：当前文档根目录的路径</li>
<li>{@value}：显示常量值</li>
<li>{@inheritDoc}：从直接父类继承的注释</li>
<li>{@link}：插入带有可见文本标签的内联链接，该标签指向引用类的指定包、类或成员名称的文档</li>
<li>{@linkplain}：同上，但是链接以纯文本显示</li>
<li>{@code}：等同于<code>&lt;code&gt;&lt;/code&gt;</code>，以代码字体显示，而不是将文本解释为HTML标记或嵌套的Javadoc标签</li>
<li>{@literal}：显示文本，而不是将文本解释为HTML标记或嵌套的Javadoc标签</li>
</ul>
<p>文档生成示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是一个用于演示文档注释的类，包含了一个&#123;<span class="doctag">@link</span> String String&#125;类型的私有字段</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> L</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> 1.8</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 设置并获取name</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@param</span> name name</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@return</span> name</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@throws</span> Exception name为空</span></span><br><span class="line"><span class="comment">	 * <span class="doctag">@see</span> Exception</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">getSet</span><span class="params">(String name)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (name == <span class="keyword">null</span> || name.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后使用<code>javadoc</code>命令（注意使用<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlLzgvZG9jcy90ZWNobm90ZXMvdG9vbHMvd2luZG93cy9qYXZhZG9jLmh0bWwjQ0hERkRBQ0I=">参数<i class="fa fa-external-link-alt"></i></span>指定编码格式）生成HTML文档，双击index.html查看</p>
<p><img src="image-20210323232401844.png" alt="image-20210323232401844"></p>
<p>在IDEA中可以通过<code>主菜单-&gt;工具-&gt;生成JavaDoc...</code>便捷的生成文档</p>
<p><img src="image-20210323232754938.png" alt="image-20210323232754938"></p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量即可以变化的量。在Java中，变量按类型可以分为基本类型的变量和引用类型的变量。按范围可以分为局部变量、类变量(静态变量)、成员变量(非静态变量、实例变量)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> i; <span class="comment">// 静态变量</span></span><br><span class="line">	<span class="keyword">char</span> c; <span class="comment">// 成员变量</span></span><br><span class="line">	String str; <span class="comment">// 成员变量，引用类型</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123; <span class="comment">// 局部变量，方法参数</span></span><br><span class="line">		<span class="keyword">float</span> f; <span class="comment">// 局部变量</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><ul>
<li>局部变量声明在方法、构造方法或者语句块中；</li>
<li>局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁；</li>
<li>访问修饰符不能用于局部变量；</li>
<li>局部变量只在声明它的方法、构造方法或者语句块中可见；</li>
<li>局部变量是在栈上分配的。</li>
<li>局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用。</li>
</ul>
<h4 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h4><ul>
<li>实例变量声明在一个类中，但在方法、构造方法和语句块之外；</li>
<li>当一个对象被实例化之后，每个实例变量的值就跟着确定；</li>
<li>实例变量在对象创建的时候创建，在对象被销毁的时候销毁；</li>
<li>实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息；</li>
<li>实例变量可以声明在使用前或者使用后；</li>
<li>访问修饰符可以修饰实例变量；</li>
<li>实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有。通过使用访问修饰符可以使实例变量对子类可见；</li>
<li>实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定；</li>
<li>实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName。</li>
</ul>
<h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><ul>
<li>类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外。</li>
<li>无论一个类创建了多少个对象，类只拥有类变量的一份拷贝。</li>
<li>静态变量除了被声明为常量外很少使用，静态变量是指声明为 public/private，final 和 static 类型的变量。静态变量初始化后不可改变。</li>
<li>静态变量储存在静态存储区。经常被声明为常量，很少单独使用 static 声明变量。</li>
<li>静态变量在第一次被访问时创建，在程序结束时销毁。</li>
<li>与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型。</li>
<li>默认值和实例变量相同。数值型变量默认值是 0，布尔型默认值是 false，引用类型默认值是 null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化。</li>
<li>静态变量可以通过：<em>ClassName.VariableName</em>的方式访问。</li>
<li>类变量被声明为 public static final 类型时，类变量名称一般建议使用大写字母。如果静态变量不是 public 和 final 类型，其命名方式与实例变量以及局部变量的命名方式一致。</li>
</ul>
<h4 id="变量的作用域"><a href="#变量的作用域" class="headerlink" title="变量的作用域"></a>变量的作用域</h4><p>变量的范围是程序中该变量可以被引用的部分。</p>
<ul>
<li>局部变量的作用范围从声明开始，直到包含它的块结束。</li>
<li>方法的参数范围涵盖整个方法，它实际上是一个局部变量。</li>
<li>循环的初始化部分声明的变量，其作用范围为整个循环体。但循环体内声明的变量其作用范围是从它声明到循环体结束。</li>
</ul>
<h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量使用<code>final</code>关键字修饰，常量名通常为全部大写，常量在定义时进行初始化后就不可再次赋值，再次赋值会导致编译错误。</p>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><table>
<thead>
<tr>
<th>类型</th>
<th>操作符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>算术运算符</td>
<td>+</td>
<td>加</td>
</tr>
<tr>
<td></td>
<td>-</td>
<td>减</td>
</tr>
<tr>
<td></td>
<td>*</td>
<td>乘</td>
</tr>
<tr>
<td></td>
<td>/</td>
<td>除</td>
</tr>
<tr>
<td></td>
<td>%</td>
<td>取余，左边的数对右边相除后的余数</td>
</tr>
<tr>
<td></td>
<td>++</td>
<td>自增</td>
</tr>
<tr>
<td></td>
<td>–</td>
<td>自减</td>
</tr>
<tr>
<td>关系运算符（值判断）</td>
<td>==</td>
<td>等于</td>
</tr>
<tr>
<td></td>
<td>!=</td>
<td>不等于</td>
</tr>
<tr>
<td></td>
<td>&gt;</td>
<td>大于</td>
</tr>
<tr>
<td></td>
<td>&lt;</td>
<td>小于</td>
</tr>
<tr>
<td></td>
<td>&gt;=</td>
<td>大于或等于</td>
</tr>
<tr>
<td></td>
<td>&lt;=</td>
<td>小于或等于</td>
</tr>
<tr>
<td>位运算符</td>
<td>&amp;</td>
<td>与，如果相对应位都是1，则结果为1，否则为0</td>
</tr>
<tr>
<td></td>
<td>|</td>
<td>或，如果相对应位都是 0，则结果为 0，否则为 1</td>
</tr>
<tr>
<td></td>
<td>^</td>
<td>非，也叫异或，如果相对应位值相同，则结果为0，否则为1</td>
</tr>
<tr>
<td></td>
<td>~</td>
<td>按位取反，0变1，1变1</td>
</tr>
<tr>
<td></td>
<td>&lt;&lt;</td>
<td>左移</td>
</tr>
<tr>
<td></td>
<td>&gt;&gt;</td>
<td>右移</td>
</tr>
<tr>
<td></td>
<td>&gt;&gt;&gt;</td>
<td>无符号右移（按位右移补零）</td>
</tr>
<tr>
<td>逻辑运算符</td>
<td>&amp;&amp;</td>
<td>逻辑与，“一假则假”</td>
</tr>
<tr>
<td></td>
<td>||</td>
<td>逻辑或，“一真则真”</td>
</tr>
<tr>
<td></td>
<td>!</td>
<td>逻辑非，“真假反转”</td>
</tr>
<tr>
<td>赋值运算符</td>
<td>=</td>
<td>赋值，将右边的值赋予左边</td>
</tr>
<tr>
<td></td>
<td>+=</td>
<td>相加后赋值，将左边原来的值与右边相加后赋予左边，下同</td>
</tr>
<tr>
<td></td>
<td>-=</td>
<td>相减后赋值</td>
</tr>
<tr>
<td></td>
<td>*=</td>
<td>相乘后赋值</td>
</tr>
<tr>
<td></td>
<td>/=</td>
<td>相除后赋值</td>
</tr>
<tr>
<td></td>
<td>%=</td>
<td>取余后赋值</td>
</tr>
<tr>
<td></td>
<td>&lt;&lt;=</td>
<td>左移后赋值</td>
</tr>
<tr>
<td></td>
<td>&gt;&gt;=</td>
<td>右移后赋值</td>
</tr>
<tr>
<td></td>
<td>&amp;=</td>
<td>按位与后赋值</td>
</tr>
<tr>
<td></td>
<td>^=</td>
<td>按位异或赋值</td>
</tr>
<tr>
<td></td>
<td>!=</td>
<td>按位非后赋值</td>
</tr>
<tr>
<td>条件运算符(三元运算符)</td>
<td>?:</td>
<td>判断第一个表达式的真假，真则值为第二个表达式，假则值为第三个表达式</td>
</tr>
<tr>
<td>类型比较</td>
<td>instanceof</td>
<td>检查该对象是否是一个指定的类型（类类型或接口类型）</td>
</tr>
<tr>
<td>字符串连接运算符</td>
<td>+</td>
<td>当表达式中含有字符或字符串时，此运算符将视为字符串的连接</td>
</tr>
</tbody></table>
<ul>
<li>逻辑运算<code>&amp;&amp;</code>和<code>||</code>是短路的</li>
<li>只能对整数类型以及字符类型进行位运算</li>
<li>位运算比算术运算效率高</li>
</ul>
<h4 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h4><p>运算优先级从高到低如下所示，不用刻意记忆，使用时可以通过括号<code>()</code>来改变优先级的顺序</p>
<table>
<thead>
<tr>
<th align="left">类别</th>
<th align="left">操作符</th>
<th align="left">关联性</th>
</tr>
</thead>
<tbody><tr>
<td align="left">后缀</td>
<td align="left">() [] . (点操作符)</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">一元：后自增、后自减</td>
<td align="left">expr++ expr–</td>
<td align="left">从左到右</td>
</tr>
<tr>
<td align="left">一元：前自增、前自减</td>
<td align="left">++expr –expr + - ～ ！</td>
<td align="left">从右到左</td>
</tr>
<tr>
<td align="left">先乘除</td>
<td align="left">* / ％</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">后加减</td>
<td align="left">+ -</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">移位</td>
<td align="left">&gt;&gt; &gt;&gt;&gt;  &lt;&lt;</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">关系</td>
<td align="left">&gt; &gt;= &lt; &lt;=</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">相等</td>
<td align="left">== !=</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">按位与</td>
<td align="left">＆</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">按位异或</td>
<td align="left">^</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">按位或</td>
<td align="left">|</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">逻辑与</td>
<td align="left">&amp;&amp;</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">逻辑或</td>
<td align="left">| |</td>
<td align="left">左到右</td>
</tr>
<tr>
<td align="left">条件</td>
<td align="left">?:</td>
<td align="left">从右到左</td>
</tr>
<tr>
<td align="left">赋值</td>
<td align="left">= += -= *= /= ％= &gt;&gt;= &lt;&lt;= ＆ = ^= |=</td>
<td align="left">从右到左</td>
</tr>
<tr>
<td align="left">逗号</td>
<td align="left">,</td>
<td align="left">左到右</td>
</tr>
</tbody></table>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><ul>
<li>基本数据类型有：byte、short、int、long、float、double、boolean、char<br>其中byte，short，int，long是整数类型，float、double是浮点数类型，char是字符类型，boolean布尔类型用于逻辑判断</li>
<li>long类型的值在书写时可以后跟大写<code>L</code>表示，float类型的值在书写时必须后跟<code>f</code>（可大写可小写）</li>
<li>整数类型的不同进制表示示例：16进制0xf，8进制077</li>
<li>char的16进制unicode字符表示法：\u0000</li>
<li>java没有无符号的数据类型</li>
</ul>
<h4 id="范围"><a href="#范围" class="headerlink" title="范围"></a>范围</h4><p>按8位=1字节，最高位表示符号位（正或负），以二进制补码计算，各种整数类型可表示的范围如下：</p>
<ul>
<li>byte：-2^7^到2^7^-1 = -128 ~ 127</li>
<li>short：-2^15^到2^15^-1 = -32768 ~ 32767</li>
<li>int：-2^31^到2^31^-1 = -2147483648 ~ 2147483647</li>
<li>long：-2^63^到2^63^-1 = -9223372036854775808 ~ 9223372036854775807</li>
</ul>
<p>char为2个字节，float为4个字节，double为8个字节</p>
<p>关于浮点数的定义，参考<span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvSUVFRV83NTQ=">IEEE 754二进制浮点数算术标准<i class="fa fa-external-link-alt"></i></span>，这里给出范围</p>
<ul>
<li>float：2^-149^到3.4*10^38^</li>
<li>double：2^-1074^到1.79*10^308^</li>
</ul>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>不同的基本数据类型之间可以混合进行计算，但需要转换先转化为同一类型。有如下三种转换形式：</p>
<h4 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h4><p>char类型与整数类型计算时char自动转换为int</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> c = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">int</span> i = c + <span class="number">1</span>; <span class="comment">// 98</span></span><br></pre></td></tr></table></figure>

<p>低精度的与高精度的计算时，低精度的先转换为高精度的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">0.1f</span>;</span><br><span class="line"><span class="keyword">double</span> d = f + <span class="number">0.1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> i = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">long</span> l = i + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>可以使用强制转换由高精度的数据类型转换到低精度的数据类型，但超过范围时会丢失精度</p>
<p>格式：(需要转换的类型) 被转换的变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">200</span>;</span><br><span class="line"><span class="keyword">byte</span> b = (<span class="keyword">byte</span>) i; <span class="comment">// -56</span></span><br></pre></td></tr></table></figure>

<p>高位字节被去掉，保留低位字节进行表示</p>
<p><img src="image-20210321234418184.png" alt="image-20210321234418184"></p>
<p>由浮点数转换到整数时，舍弃小数部分</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> f = <span class="number">1.23f</span>;</span><br><span class="line"><span class="keyword">int</span> i = (<span class="keyword">int</span>) f; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<h4 id="隐含强制类型转换"><a href="#隐含强制类型转换" class="headerlink" title="隐含强制类型转换"></a>隐含强制类型转换</h4><p>所有的整数进行计算时会提升到默认类型int</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span> b = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">short</span> s = (<span class="keyword">short</span>) (b + <span class="number">1</span>); <span class="comment">// 需要强制转换，因为计算时默认类型为int</span></span><br><span class="line"><span class="keyword">int</span> i = b + <span class="number">2</span>; <span class="comment">// 不需要强制转换</span></span><br></pre></td></tr></table></figure>

<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><ul>
<li><p>条件判断：if或者if…else</p>
</li>
<li><p>循环：for(;;)、for(:)、while()和do,,,while</p>
</li>
<li><p>多重选择：switch…case，可用于整数类型和字符（串）类型，当没有匹配到任何case语句时执行default分支</p>
</li>
<li><p>break用于结束多重选择或跳出整个循环体</p>
</li>
<li><p>continue用于结束当次循环，跳转到下一次循环</p>
</li>
</ul>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是相同数据类型的集合，数组是引用类型，一旦创建后大小不能改变，使用<code>数组名.length</code>来获得数组中的元素数量</p>
<p>数组中的元素初始化时若未赋值，将使用默认值，整型都是<code>0</code>，浮点型是<code>0.0</code>，布尔型是<code>false</code>，字符为<code>\0</code>（控制字符，ASCII代码0），引用类型为<code>null</code></p>
<p>声明数组的方式有两种，推荐使用前者，后者是为了照顾C/C++的程序员</p>
<ul>
<li>数据类型[] 数组名</li>
<li>数据类型 数组名[]</li>
</ul>
<p>创建数组的方式（第三种为静态初始化，仅用于声明的同时赋值，不能对已赋值数组进行二次赋值）</p>
<ul>
<li>new 数据类型[数组大小]</li>
<li>new 数据类型[]{ 数据1, 数据2, 数据3, …, 数据n }</li>
<li>{ 数据1, 数据2, 数据3, …, 数据n }</li>
</ul>
<p>通过索引值访问数组元素，索引值从<code>0</code>开始到<code>length-1</code>。如果越界，会抛出<code>ArrayIndexOutOfBoundsException</code></p>
<h4 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h4><p>使用多维数组与一维数组相似：数据类型[][] 数组名 = { {数据1, 数据2, 数据3, …, 数据n}, …, {数据1, 数据2, 数据3, …, 数据n} }</p>
<p>也可以创建锯齿型数组，例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] array = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>, <span class="number">5</span>&#125;,</span><br><span class="line">    &#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="基本输入与输出"><a href="#基本输入与输出" class="headerlink" title="基本输入与输出"></a>基本输入与输出</h3><p>通过<code>Scanner</code>对象获取简单的文本扫描器，可以使用正则表达式解析基本类型和字符串，将标准输入流对象<code>System.in</code>传入构造方来扫描控制台输入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">	System.out.print(<span class="string">"输入字符串："</span>);</span><br><span class="line">	<span class="keyword">if</span> (sc.hasNext()) &#123;</span><br><span class="line">		String str = sc.next();</span><br><span class="line">		System.out.println(<span class="string">"str = "</span> + str);</span><br><span class="line">	&#125;</span><br><span class="line">	sc.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20210408163038589.png" alt="image-20210408163038589"></p>
<p>方法说明</p>
<ul>
<li><code>hasNext()</code>：判断是否还有输入</li>
<li><code>hasNextLine()</code>：判断是否还有下一行输入</li>
<li><code>next()</code>：接收字符串，以空格为结束标志</li>
<li><code>nextLine()</code>：接受一整行字符串</li>
<li><code>hasNextXxx()</code>：Xxx为数据类型，判断是否还有对应类型的输入</li>
<li><code>nextXxx()</code>：Xxx为数据类型，将输入转换为对应类型，无法转换时抛出<code>InputMismatchException</code></li>
<li><code>close()</code>：关闭Scanner对象</li>
</ul>
<p><code>System.out</code>是标准输出流对象，用于向控制台输出消息，其常用的方法有</p>
<ul>
<li><code>println()</code>：有多种重载方法，直接输出换行或者接收任何对象输出其数据并换行，接收<code>Object</code>类型时会先调用<code>String.valueOf()</code>。具体使用的换行符取决于系统</li>
<li><code>print()</code>：同上，但不会换行，并且不接收空参数</li>
<li><code>printf()</code>：类似于c语言的printf函数，使用指定的格式字符串和参数将格式化的字符串输出</li>
<li><code>format()</code>：同上</li>
</ul>
<h3 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h3><ul>
<li><span class="exturl" data-url="aHR0cHM6Ly9nb29nbGUuZ2l0aHViLmlvL3N0eWxlZ3VpZGUvamF2YWd1aWRlLmh0bWw=">Google Java编程风格规范<i class="fa fa-external-link-alt"></i></span>，<span class="exturl" data-url="aHR0cHM6Ly9qZXJ2eXNoaS5naXRib29rcy5pby9nb29nbGUtamF2YS1zdHlsZWd1aWRlLXpoL2NvbnRlbnQvaW5kZXguaHRtbA==">中文版<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuYWxpeXVuLmNvbS9zcGVjaWFsL3RlY2gtamF2YQ==">阿里巴巴Java开发手册<i class="fa fa-external-link-alt"></i></span></li>
<li><span class="exturl" data-url="aHR0cDovL2phdmEuc3VuLmNvbS9kb2NzL2Jvb2tzL2pscy9pbmRleC5odG1s">Oracle Java语言规范<i class="fa fa-external-link-alt"></i></span></li>
</ul>
<h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><blockquote>
<p>面向对象程序设计是种具有对象概念的编程典范，同时也是一种程序开发的抽象方针。它可能包含数据、属性、代码与方法。对象则指的是类（class）的实例。它将对象作为程序的基本单元，将程序和数据封装其中，以提高软件的重用性、灵活性和扩展性，对象里的程序可以访问及经常修改对象相关连的数据。在面向对象程序编程里，计算机程序会被设计成彼此相关的对象。</p>
</blockquote>
<h3 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h3><p>面向对象的编程语言具有如下三大特征：</p>
<ul>
<li>封装：将抽象性函数接口的实现细节部分包装、隐藏起来的方法。<br>具备封装性的面向对象程序设计隐藏了某一方法的具体运行步骤，取而代之的是通过消息传递机制发送消息给它。封装是通过限制只有特定类的对象可以访问这一特定类的成员，而它们通常利用接口实现消息的传入传出。</li>
<li>继承：在某种情况下，一个类会有“子类”。子类比原本的类（称为父类）要更加具体化。子类会继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法。</li>
<li>多态：多态的原义是指生物学中表示生物或物种可以具有许多不同的形式或阶段。这个原则也可以应用于面向对象的编程语言，即类的子类可以定义它们自己的唯一行为，但仍然共享父类的一些相同功能。由继承而产生的相关的不同的类，其对象对同一消息会做出不同的响应</li>
</ul>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>类（class）是创建对象的蓝图，是能描述一类事物行为和状态的模板或者说所创建的对象共同的属性和方法。</p>
<h4 id="字段-属性"><a href="#字段-属性" class="headerlink" title="字段(属性)"></a>字段(属性)</h4><p>在一个类中定义的字段有两种，一种是实例字段。实例字段的特点是，不同的实例有各自的字段，独立使用互不影响。</p>
<p>另一种使用<code>static</code>修饰的字段是静态字段，也叫类字段。静态字段是类独有的，所有实例都会共享该字段</p>
<p>使用<code>final</code>修饰的字段在初始化后不能被改变</p>
<h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><p>使用<code>abstract</code>关键字修饰的类叫抽象类，它可以包含抽象方法。抽象类无法实例化，但可以进行子类化</p>
<ul>
<li>如果一个类包含抽象方法，那么类本身必须则声明为<code>abstract</code></li>
<li>当抽象类被子类化时，其子类需要实现父类中所有的抽象方法，若没有则子类必须声明为<code>abstract</code></li>
<li>抽象类可以包含静态字段和方法，同样使用类名进行引用</li>
<li>抽象类可以实现接口，且不用实现所有方法，但此抽象类的非抽象子类必须实现其接口的所有方法</li>
</ul>
<blockquote>
<p>抽象类被定义为永远不会也不能被实例化为具体对象的一种类。它往往用于定义一种抽象上的概念，在类的继承关系中它往往处在较上层的位置。在程序设计的实践活动中，抽象类与接口存在类似的地方，即它更偏重于对共通的方法和属性进行规约。但与接口存在一个非常大的差异则在于，抽象类往往可以规约一个共同的方法和属性时提供一个对他们的实现。</p>
</blockquote>
<h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><p>使用关键字<code>interface</code>来申明一个接口。接口可以规定方法的原型：方法名、参数列表以及返回类型，但不能规定方法的实现</p>
<ul>
<li>一个类只能有一个父类，但可以实现（implements）多个接口。即“单继承，多实现”</li>
<li>接口默认是抽象的，声明接口的时候不需要使用abstract关键字。</li>
<li>接口中的方法默认也是抽象的，所以方法的abstract关键字也不需要。</li>
<li>接口中的所有方法默认是public的。所以不需要使用public关键字（用了也不影响，编译器会忽略）</li>
<li>接口可以继承（extends）其他接口，类似于子类继承父类，相当于扩展了接口的方法</li>
</ul>
<h5 id="比较接口与抽象类"><a href="#比较接口与抽象类" class="headerlink" title="比较接口与抽象类"></a>比较接口与抽象类</h5><table>
<thead>
<tr>
<th></th>
<th>接口</th>
<th>抽象类</th>
</tr>
</thead>
<tbody><tr>
<td>实例化</td>
<td>不能</td>
<td>不能</td>
</tr>
<tr>
<td>定义字段</td>
<td>所有字段均为public、static和final的</td>
<td>可以声明非静态和final的</td>
</tr>
<tr>
<td>定义方法</td>
<td>所有方法均为public的</td>
<td>支持所有访问修饰符的方法</td>
</tr>
<tr>
<td>继承</td>
<td>只能继承接口</td>
<td>单继承</td>
</tr>
<tr>
<td>实现</td>
<td>可以实现多个接口</td>
<td>可以实现多个接口</td>
</tr>
</tbody></table>
<p><strong>使用抽象类还是接口？</strong></p>
<ul>
<li>使用抽象类：当需要在几个密切相关的类之间共享代码，或者需要除public之外的访问修饰符(例如protected和private)，或需要声明非static或非final字段时</li>
<li>使用接口：会有不相关的类将实现你的接口，或指定特定数据类型的行为，但不关心谁实现其行为，以及想要利用类的多重继承机制时</li>
</ul>
<h4 id="嵌套类"><a href="#嵌套类" class="headerlink" title="嵌套类"></a>嵌套类</h4><blockquote>
<p>嵌套类分为两类：静态和非静态。声明为 <code>static</code> 的嵌套类称为静态嵌套类(static nested classes)。非静态嵌套类称为内部类(inner classes)。</p>
</blockquote>
<h5 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h5><p>内部类即在类中定义的类</p>
<p>要实例化内部类，必须先实例化外部类，然后通过外部类的实例来实例化内部类。内部类可以直接访问外部类的方法和字段（包括private的）。但是由于内部类与实例相关联，所以无法定义任何静态字段或方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		OuterClass out = <span class="keyword">new</span> OuterClass(<span class="string">"outerClass"</span>);</span><br><span class="line">		OuterClass.InnerClass in = out.<span class="keyword">new</span> InnerClass();</span><br><span class="line">		in.print();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">OuterClass</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.name = name;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">        	<span class="keyword">static</span> <span class="keyword">int</span> i; <span class="comment">// error</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"InnerClass"</span> + name);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h5><p>可以用<code>static</code>修饰内部类使其成为静态内部类。同样的，使用静态内部类，需要通过外部类的实例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		OuterClass.InnerClass in = <span class="keyword">new</span> OuterClass.InnerClass();</span><br><span class="line">		in.print();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterClass</span> </span>&#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			System.out.println(<span class="string">"InnerClass"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="局部类"><a href="#局部类" class="headerlink" title="局部类"></a>局部类</h5><p>也叫本地类（local class），是一种在方法体中，for 循环或 if 子句中定义的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="class"><span class="keyword">class</span> <span class="title">LocalClass</span> </span>&#123;</span><br><span class="line">			<span class="function"><span class="keyword">void</span> <span class="title">list</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				<span class="keyword">for</span> (String arg : args) &#123;</span><br><span class="line">					System.out.println(arg);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">new</span> LocalClass().list();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>局部类可以访问局部变量。但是只能访问 final 或 effectively final (实际上 final，在初始化之后其值永远不会更改的) 的封闭块的局部变量和参数。</li>
<li>在方法中声明的局部类可以访问方法的参数</li>
<li>局部类与内部类类似，无法定义或声明任何静态字段或方法</li>
<li>不能在一个语句块内声明一个接口，因为接口本质上是静态的（不能被实例化）</li>
<li>局部类可以有静态字段，前提是它们是常量，即使用<code>final static</code>修饰</li>
</ul>
<h5 id="匿名类"><a href="#匿名类" class="headerlink" title="匿名类"></a>匿名类</h5><p>不能实例化接口，但可以使用匿名类的方式来创建接口的对象。只会使用一次的局部类可以更改成匿名类，它能够同时声明和实例化一个要实现的接口或要继承的类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Anonymous anonymous = <span class="keyword">new</span> Anonymous() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span><span class="params">()</span> </span>&#123;</span><br><span class="line">				System.out.println(<span class="string">"Anonymous"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		anonymous.say();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Anonymous</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>不能在匿名类中声明构造函数</li>
<li>匿名类的主体中可以声明方法，但不能使用语句</li>
<li>局部类是类声明，但匿名类是表达式，所以它必须是语句的一部分，即末尾需要有一个分号</li>
<li>与局部类相同，无法在匿名类中定义或声明任何静态字段或方法</li>
<li>但同样的，可以具有<code>final static</code>修饰的常量</li>
</ul>
<hr>
<p>有这么多不同类型的嵌套类，那何时使用嵌套类，局部类，匿名类呢？</p>
<blockquote>
<p>当需要声明字段或其他方法，使用匿名类</p>
<p>当需要创建多个类的实例，访问其构造方法或引入新的类时，使用局部类</p>
<p>如果需求与局部类相似，但希望更广泛地使用，并且不需要访问局部变量或方法参数时，且需要访问非公共字段和方法时，使用非静态嵌套类（内部类），否则使用静态嵌套类</p>
</blockquote>
<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>枚举是一种特殊的类，使用<code>enum</code>关键字定义，它使变量成为一组预定义的常量，使用时变量必须等于其预定义的值之一。因为是常量，所以枚举的字段名称通常全为大写字母。</p>
<blockquote>
<p>所有枚举隐式继承 java.lang.Enum。因为一个类只能继承一个父类，所以枚举不能继承任何其他类。<br>枚举类型的构造函数必须是包私有或私有访问，它会在枚举主体开头自动创建定义的常量。你不能自己调用枚举的构造函数。<br>可以声明枚举的实例，但不能实例化枚举类型，即不能使用new操作符创建枚举实例</p>
</blockquote>
<p>可以在枚举类主体内定义方法和其他字段。或者定义枚举常量的字段值，（在常量创建时）使用构造函数将这些值传递给枚举常量。<br>必须在任何字段或方法之前首先定义常量。此外，当存在字段和方法时，枚举常量列表必须以分号结尾。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Color &#123;</span><br><span class="line">	BLACK(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>),</span><br><span class="line">	WHITE(<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>),</span><br><span class="line">	YELLOW(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> r;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> g;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">	Color(<span class="keyword">int</span> r, <span class="keyword">int</span> g, <span class="keyword">int</span> b) &#123;</span><br><span class="line">		<span class="keyword">this</span>.r = r;</span><br><span class="line">		<span class="keyword">this</span>.g = g;</span><br><span class="line">		<span class="keyword">this</span>.b = b;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getR</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> r; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getG</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> g; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getB</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> b; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>枚举类的字段也可以是非final类型，即可以在运行期修改，但是不推荐这样做</strong></p>
<p>编译器在创建枚举时会自动添加一些特殊的方法</p>
<ul>
<li><p>静态方法<code>values()</code>：该方法返回一个数组，此数组按照声明的顺序包含了枚举的所有值。此方法通常用于迭代枚举类型的值</p>
</li>
<li><p>常量的final方法<code>name()</code>：返回当前枚举常量的名称，与枚举中声明的名称完全相同</p>
</li>
<li><p>常量的final方法<code>ordinal()</code>：返回此枚举常量的序号（其在枚举声明中的位置，从0开始）。大多数情况下不会使用这种方法，它被设计用于复杂的基于枚举的数据结构</p>
</li>
</ul>
<blockquote>
<p>因<code>toString()</code>方法可被重写，所以当需要枚举常量的原始名称时，应使用<code>name()</code>方法；需要具有可读性时，使用<code>toString()</code>方法</p>
</blockquote>
<h3 id="对象-实例"><a href="#对象-实例" class="headerlink" title="对象(实例)"></a>对象(实例)</h3><p>对象是类的一个实例，有状态和行为。一个典型的 Java 程序会创建许多对象，它们通过调用方法进行交互。通过这些对象的交互程序可以执行各种任务</p>
<p>使用<code>new</code>操作符从一个类中创建一个对象，对象名作为<a href="#标识符">标识符</a>需要符合其命名规则。<code>new</code>操作符通过为新对象分配内存并返回对该内存的引用来实例化一个类。<code>new</code>操作符也会调用对象的构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type name &#x3D; new Constructor(zero or more parameters);</span><br></pre></td></tr></table></figure>

<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><blockquote>
<p>方法（Method）指的是对象（所谓的实例方法）的一种子程序。形同面向过程编程里的函数，一个方法通常以一系列的语句所组成，并以之完成一个动作。其可以借由输入一组参数以制订所需的动作，且一部分的方法可能会有输出值（返回值）。方法的目的是提供一个机制，以访问（对于读和写）对象的私有资料存储区。</p>
</blockquote>
<p>方法声明的必需元素包括方法的返回类型、名称、一对括号 <code>()</code>， 以及在大括号 <code>{}</code> 之间的方法主体。完整的方法声明有以下6个部分：</p>
<ol>
<li>访问修饰符（如 <code>public</code>，<code>private</code>）</li>
<li>方法返回的值的数据类型，如果该方法不需要返回值，则为<code>void</code></li>
<li>方法名称，规范与<a href="#标识符">标识符</a>类似，但略有不同</li>
<li>括号中的形式参数列表，以逗号分割并以它们的数据类型为开头，由括号<code>()</code>括起来。如果没有参数，则必须使用空括号</li>
<li>一个异常列表，以<code>throws</code>声明并以逗号分割的异常类型，说明这个方法可能会抛出的一个或多个异常</li>
<li>方法体，在括号<code>{}</code>之间的代码，其中可以包括局部变量的声明</li>
</ol>
<blockquote>
<p>方法名称和参数类型构成为方法的签名（signature）</p>
</blockquote>
<h4 id="方法的参数"><a href="#方法的参数" class="headerlink" title="方法的参数"></a>方法的参数</h4><p>除了普通的方法参数外，有一种特殊的参数叫可变参数：可以在参数列表的<strong>最后一个</strong>参数的类型后面使用三个点(<code>...</code>)，空格和参数名称来创建可变数量的参数方式，当不清楚有多少特定类型的参数会传递给该方法时，就可以使用可变参数，这是手动创建数组的快捷方式，可以传入任意数量的参数来调用该方法，包括零个。</p>
<p>可以将任何数据类型用于方法的参数，但需要注意</p>
<ul>
<li>基本数据类型（如int、double）通过值传递到方法中，这意味着对参数值的任何更改仅存在于该方法的范围内，当该方法返回时，参数将消失，对其进行的任何更改都将丢失。</li>
<li>引用数据类型（对象、数组）也是通过值传递到方法中。这意味着当方法返回时，传入的引用仍然引用与之前相同的对象。所以，如果对象的字段值具有适当的访问级别，则可以在该方法中更改该字段。</li>
</ul>
<p>运行以下程序，其中point对象的字段值x与y变化了，但是i还是原来的值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	Point point = <span class="keyword">new</span> Point(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">	<span class="keyword">int</span> i = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">	movePoint(point, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">movePoint</span><span class="params">(Point p, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">	p.move(i, i);</span><br><span class="line">	i = <span class="number">0</span>;</span><br><span class="line">	System.out.println(<span class="string">"move over"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>又叫构造函数，类似于一般的方法，除了<strong>命名与类名相同并且没有返回类型</strong>，它是在创建一个类的实例时自动调用的。可以使用构造函数来初始化实例的字段</p>
<p>编译器会自动为任何没有构造函数的类提供一个无参数的默认构造函数。这个默认构造函数将调用父类的无参构造函数。在这种情况下，如果超类没有无参构造函数，编译器会发出警告，因此你必须确认它是否存在。没有显式父类时，隐式父类为<code>Object</code>，其有一个无参的构造函数。</p>
<p>子类继承父类时，创建子类对象会先调用父类构造方法再调用子类的构造方法</p>
<blockquote>
<p>如果一个类的构造函数不能被调用，那么它就不能直接创建对象。</p>
</blockquote>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>使用<code>static</code>修饰的方法就叫静态方法，或者类方法。一个典型的例子：作为程序入口的main方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>调用实例方法必须通过一个实例变量，而调用静态方法则不需要实例变量，通过类名就可以调用。静态方法更类似于其它编程语言的函数</p>
<p><strong>静态方法内只能访问静态字段</strong></p>
<h4 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h4><blockquote>
<p>方法重载（Overload）：当存在多个同名方法但方法之间形式参数的数据类型不同或数量不同时，即为方法重载。</p>
</blockquote>
<ul>
<li>重载的方法的返回值可以不同，但是如果重载的方法之间只有返回值不同就不足以构成重载。因为编译器在区分不同的重载方法时不考虑返回类型，所以即使它们具有不同的返回类型，也不能声明具有相同签名（即方法名称和参数类型）的两个方法。</li>
<li>访问修饰符也可以不同，规则同上，如果仅有访问修饰符不同就不能构成重载</li>
<li>重载的方法可以声明新的或更多的抛出异常</li>
<li>不能声明多个具有相同名称和相同数量与类型的参数的方法，因为编译器无法区分</li>
<li>构造方法也可以重载，重载方式与普通方法的重载形式一样，唯一不同的是没有返回值的声明</li>
</ul>
<h4 id="方法重写-覆写"><a href="#方法重写-覆写" class="headerlink" title="方法重写(覆写)"></a>方法重写(覆写)</h4><blockquote>
<p>方法重写（Override）：子类通过提供与父类（超类）中的方法具有相同签名（名称和参数）以及相同返回类型的方法，子类中的实现将覆盖父类（超类）中的实现，这种子类方法的实现就叫方法重写。具体执行的方法将由调用该方法的对象确定。</p>
</blockquote>
<ul>
<li>重写方法时，使用<code>@Override</code>注解用来指示编译器将要覆盖父类中的方法。如果重写的方法没有使用此注解，编译不会报错；如果被重写的方法不存在且子类方法使用了此注解，编译则报错</li>
<li>重写的方法不能抛出新的异常或者比被重写的方法申明范围更广的异常</li>
<li>被<code>final</code>关键字修饰的方法不能被重写</li>
<li>重写的方法的访问权限不能比父类中被重写的方法的访问权限低（public&gt;protected&gt;package&gt;private）</li>
<li>参考<a href="#修饰符的访问范围">修饰符的访问范围</a>：如子类与父类在同一个包中，那么子类可以重写父类无访问修饰符的方法，若不再同一个包中则不行</li>
<li>如果不能继承一个类（被<code>final</code>修饰），则不能重写该类的方法</li>
<li>重写方法还可以返回由被重写方法返回类型的子类型。此子类型称为协变（covariant）返回类型</li>
<li>使用<code>super</code>关键字在子类中调用父类的被重写方法，使用<code>super(参数列表)</code>调用父类的构造方法</li>
<li>子类可以重载（Overload）从超类继承的方法，这样的重载方法既不隐藏也不覆盖超类实例方法，它们是新方法，对于子类是唯一的。</li>
</ul>
<h5 id="被隐藏的方法"><a href="#被隐藏的方法" class="headerlink" title="被隐藏的方法"></a>被隐藏的方法</h5><blockquote>
<p>如果子类定义的静态方法与父类中的静态方法具有相同的签名（名称和参数），则子类方法隐藏父类中的方法。</p>
</blockquote>
<ul>
<li>因为通过实例进行调用，所以被调用的重写实例方法的是子类中的方法。</li>
<li>因为静态方法总是通过类名来进行调用，所以被调用的隐藏静态方法取决于它是从父类还是从子类调用的。</li>
</ul>
<p>以下代码中<code>Main</code>类包含一个实例方法和一个静态方法以及用于程序入口的main方法，<code>SubMain</code>继承了<code>Main</code>类，它重写<code>Main</code>了中的实例方法，并隐藏<code>Main</code>中的静态方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Main m = <span class="keyword">new</span> SubMain();</span><br><span class="line">		Main.testStaticMethod();</span><br><span class="line">		m.testMethod();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Main - testMethod"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStaticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"Main - testStaticMethod"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubMain</span> <span class="keyword">extends</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"subMain - testMethod"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testStaticMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"subMain - testStaticMethod"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果<img src="image-20210325222315531.png" alt="image-20210325222315531"></p>
<hr>
<p>定义与父类的方法具有相同签名的方法时会发生的情况：</p>
<table>
<thead>
<tr>
<th></th>
<th>父类实例方法</th>
<th>父类静态方法</th>
</tr>
</thead>
<tbody><tr>
<td>子类实例方法</td>
<td>重写（Overrides）</td>
<td>编译报错</td>
</tr>
<tr>
<td>子类静态方法</td>
<td>编译报错</td>
<td>隐藏（Hide）</td>
</tr>
</tbody></table>
<h4 id="接口方法"><a href="#接口方法" class="headerlink" title="接口方法"></a>接口方法</h4><p>实现接口的类必须实现接口中声明的所有方法</p>
<ul>
<li>重写的方法不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常</li>
<li>重写的方法要保持与接口中一致的方法名，并且应该保持相同或者相兼容的返回值类型</li>
<li>接口中的静态方法永远不会被继承</li>
</ul>
<h5 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h5><p>默认方法是接口中可以有方法体的方法之一，其使用<code>default</code>关键字修饰。作用在于提供给实现类可选的实现方法，而不是必选项，在接口中可以有其默认的实现</p>
<p>默认方法在被实现类重写时，形式与接口方法一样，而无需继续使用<code>default</code>关键字</p>
<p>默认方法的方便之处在于，当一个接口需要扩展方法时，需要对每一个已实现接口的类进行方法补充，而默认方法则避免了这一问题的产生</p>
<p>当一个接口继承包含默认方法的接口时，可以执行以下操作：</p>
<ul>
<li>不提及默认方法，它允许继承的接口继承默认方法。</li>
<li>使用<code>abstract</code>重新声明默认方法。</li>
<li>重新定义默认方法，将重写该方法。</li>
</ul>
<h5 id="接口的静态方法"><a href="#接口的静态方法" class="headerlink" title="接口的静态方法"></a>接口的静态方法</h5><p>除了默认方法，还可以在接口中定义静态方法。与默认方法不同的是，<strong>接口中的静态方法永远不会被继承</strong>，因为静态方法是一种与定义它的类相关联的方法，而不是与任何对象相关联的方法，类的每个实例都共享其静态方法。</p>
<hr>
<p>默认方法、抽象方法与实例方法一样都可以被继承。但是，当类或接口的超类提供具有相同签名的多个默认方法时，编译器将遵循以下两个规则来解决名称冲突：</p>
<ol>
<li><p>实例方法优于接口默认方法。下列代码输出为software</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">extends</span> <span class="title">Software</span> <span class="keyword">implements</span> <span class="title">Game</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Main main = <span class="keyword">new</span> Main();</span><br><span class="line">		System.out.println(main.myName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Software</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">myName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"software"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">default</span> String <span class="title">myName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"game"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>已被其他候选覆盖的方法将被忽略。即A类实现B接口，B接口继承了C接口，B接口与C接口均有相同的默认方法时，就会出现这种情况，因为此时B接口的方法被解释为重写了C接口的方法。下列代码输出为mobile game</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">implements</span> <span class="title">MobileGame</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Main main = <span class="keyword">new</span> Main();</span><br><span class="line">		System.out.println(main.myName());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">default</span> String <span class="title">myName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"game"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MobileGame</span> <span class="keyword">extends</span> <span class="title">Game</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">default</span> String <span class="title">myName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"mobile game"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>如果两个或多个独立定义的默认方法冲突，或者默认方法与抽象方法冲突，则会产生编译错误，此时必须显式覆盖超类的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> <span class="keyword">implements</span> <span class="title">MobileGame</span>, <span class="title">ComputerGame</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">myName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"Main"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ComputerGame</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">default</span> String <span class="title">myName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"computer game"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MobileGame</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">default</span> String <span class="title">myName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">"mobile game"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h4><p>抽象方法指只有方法声明，而没有具体方法体的方法(没有大括号，后跟分号)。只会存在于抽象类或接口中</p>
<h3 id="包及类的访问作用域"><a href="#包及类的访问作用域" class="headerlink" title="包及类的访问作用域"></a>包及类的访问作用域</h3><p>与命名空间（namespace）类似，可以把不同的类放进包（package）来进行管理，在类文件的第一条语句使用<code>package 包路径</code>来声明类所在的包，使用<code>import 类的完整路径</code>来导入其它包的类，或者<code>import static 类的完整路径.静态变量或方法</code>来导入类的静态变量或方法</p>
<p>不同包中的类名可以相同，但是同时调用不同包中的同名类时需要将其中一个加上包名（完整路径）进行区分</p>
<p>java会默认导入<code>java.lang</code>包下的所有类</p>
<p>类的访问作用域参考<a href="#修饰符的访问范围">修饰符的访问范围</a></p>
<h2 id="常用核心类"><a href="#常用核心类" class="headerlink" title="常用核心类"></a>常用核心类</h2><blockquote>
<p><code>java.lang</code>和<code>java.util</code>包提供了几乎所有应用程序都会使用到的基本功能，以<code>java.lang</code>和<code>java.util</code>开头的软件包则为特定功能提供了补充API。</p>
</blockquote>
<h3 id="字符串String"><a href="#字符串String" class="headerlink" title="字符串String"></a>字符串String</h3><p>字符串广泛应用于编程中，在java里String属于引用类型（不是基本数据类型），但编译器会对其做特殊处理。</p>
<p>使用双引号<code>&quot;&quot;</code>来直接创建一个字符串，或者通过<code>new</code>关键字调用构造方法来创建，区别在于当内容相同时前者在引用上是相同的，而后者不同</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	String str1 = <span class="string">"test"</span>;</span><br><span class="line">	String str2 = <span class="string">"test"</span>;</span><br><span class="line">	String str3 = <span class="keyword">new</span> String(<span class="string">"test"</span>);</span><br><span class="line">	String str4 = <span class="keyword">new</span> String(<span class="string">"test"</span>);</span><br><span class="line">	System.out.println(str1 == str2);</span><br><span class="line">	System.out.println(str3 == str4);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上程序输出<img src="image-20210327235754443.png" alt="image-20210327235754443"></p>
<ul>
<li><p>比较两个字符串对象的内容是否相等，必须使用<code>equals()</code>方法（String类重写了此方法，其按字符逐个比较），<code>==</code>作用于对象只能比较引用是否相同<br>所以空字符串<code>&quot;&quot;</code>和空对象<code>null</code>是两个概念，在判断一个字符串是否为空前，要先判断对象是否为空，否则会产生<code>NullPointerException</code>异常</p>
</li>
<li><p>String类是final的，所以不能被继承。同时字符串也是常量，即不可变的，因为其内部使用一个<code>private final char value[]</code>字段作为字符存储管理，即对原字符串做的任何处理都会创建一个新的引用对象，并且不会改变原字符串<br><img src="image-20210328194831344.png" alt="image-20210328194831344"></p>
</li>
<li><p>使用<code>+</code>运算符来连接字符串，并且也对其他对象转换为字符串提供了特殊支持。下面的代码被编译为字节码后，使用<code>javap -verbose class文件名</code>命令解析后可知，在执行时，字符串连接是通过<code>StringBuilder</code>（或<code>StringBuffer</code>）类及其<code>append()</code>方法实现的。字符串转换是通过<code>toString()</code>方法实现的（该方法由<code>Object</code>定义并由Java中的所有类继承）</p>
</li>
</ul>
<p><img src="image-20210329012311006.png" alt="image-20210329012311006"></p>
<p>一些常用的字符串方法：</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td>public char charAt(int index)</td>
<td align="left">返回指定索引位置的字符值</td>
</tr>
<tr>
<td>public int compareTo(String anotherString)</td>
<td align="left">按字典顺序比较两个字符串（基于Unicode值）。如果String对象按字典顺序排列在anotherString之前，结果为负整数，否则为正整数。如果字符串相等，则为0</td>
</tr>
<tr>
<td>public int compareToIgnoreCase(String str)</td>
<td align="left">同上，但忽略大小写</td>
</tr>
<tr>
<td>public String concat(String str)</td>
<td align="left">等同于<code>+</code>，将指定的字符串连接到原字符串的末尾，将会返回新的字符串</td>
</tr>
<tr>
<td>public boolean contains(CharSequence s)</td>
<td align="left">当且仅当此字符串包含指定的字符时，返回true</td>
</tr>
<tr>
<td>public boolean endsWith(String suffix)</td>
<td align="left">检查字符串是否以指定的后缀结尾</td>
</tr>
<tr>
<td>public boolean equals(Object anObject)</td>
<td align="left">将此字符串与指定对象进行比较，当且仅当对象为String类型和内容相等时，返回true</td>
</tr>
<tr>
<td>public boolean equalsIgnoreCase(String anotherString)</td>
<td align="left">同上，但忽略大小写</td>
</tr>
<tr>
<td>public static String format(String format, Object… args)</td>
<td align="left">使用指定的格式字符串和参数返回格式化的字符串。<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlLzgvZG9jcy9hcGkvamF2YS91dGlsL0Zvcm1hdHRlci5odG1s">格式化语法参考<i class="fa fa-external-link-alt"></i></span></td>
</tr>
<tr>
<td>public int indexOf(int ch)</td>
<td align="left">返回指定字符第一次出现在此字符串中的位置，没有则返回-1</td>
</tr>
<tr>
<td>public int indexOf(int ch, int fromIndex)</td>
<td align="left">同上，但指定开始位置</td>
</tr>
<tr>
<td>public int indexOf(String str)</td>
<td align="left">返回指定字符串第一次出现在此字符串中的位置，没有则返回-1</td>
</tr>
<tr>
<td>public int indexOf(String str, int fromIndex)</td>
<td align="left">同上，但指定开始位置</td>
</tr>
<tr>
<td>public int length()</td>
<td align="left">返回此字符串的长度</td>
</tr>
<tr>
<td>public boolean isEmpty()</td>
<td align="left">当且仅当字符串长度为0时返回true（不能用于判断对象是否为空）</td>
</tr>
<tr>
<td>public static String join(CharSequence delimiter, CharSequence… elements)</td>
<td align="left">返回一个由指定元素和分隔符组成的字符串</td>
</tr>
<tr>
<td>public int lastIndexOf(int ch)</td>
<td align="left">返回指定字符最后一次出现在此字符串中的位置，没有则返回-1</td>
</tr>
<tr>
<td>public int lastIndexOf(int ch, int fromIndex)</td>
<td align="left">同上，但指定开始位置</td>
</tr>
<tr>
<td>public int lastIndexOf(String str)</td>
<td align="left">返回指定字符串最后一次出现在此字符串中的位置，没有则返回-1</td>
</tr>
<tr>
<td>public int lastIndexOf(String str, int fromIndex)</td>
<td align="left">同上，但指定开始位置</td>
</tr>
<tr>
<td>public boolean matches(String regex)</td>
<td align="left">判断此字符串是否与给定的正则表达式匹配</td>
</tr>
<tr>
<td>public String replace(char oldChar, char newChar</td>
<td align="left">将旧字符替换为新字符并返回一个新字符串</td>
</tr>
<tr>
<td>public String replace(CharSequence target, CharSequence replacement)</td>
<td align="left">将旧字符序列替换为新字符序列并返回一个新字符串</td>
</tr>
<tr>
<td>public String[] split(String regex)</td>
<td align="left">使用给定正则表达式将字符串拆分为字符串数组</td>
</tr>
<tr>
<td>public boolean startsWith(String prefix)</td>
<td align="left">检查字符串是否以指定的前缀开始</td>
</tr>
<tr>
<td>public String substring(int beginIndex)</td>
<td align="left">从给定位置开始到结尾返回一个子字符串</td>
</tr>
<tr>
<td>public String substring(int beginIndex, int endIndex)</td>
<td align="left">从给定位置开始到给定结束位置返回一个子字符串</td>
</tr>
<tr>
<td>public char[] toCharArray()</td>
<td align="left">将此字符串转换为新的字符数组。</td>
</tr>
<tr>
<td>public String toLowerCase()</td>
<td align="left">将所有字符串转换为小写</td>
</tr>
<tr>
<td>public String toUpperCase()</td>
<td align="left">将所有字符串转换为大写</td>
</tr>
<tr>
<td>public String trim()</td>
<td align="left">返回去除前导空白和尾随空白后的字符串，包括空格，<code>\t</code>，<code>\r</code>，<code>\n</code>，<code>\u3000</code>（全角空格）</td>
</tr>
<tr>
<td>public static String valueOf(Object obj)</td>
<td align="left">将对象转换为字符串，其提供有不同数据类型参数的共9种重载方法</td>
</tr>
</tbody></table>
<h4 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h4><p>由于字符串是不可变对象，对字符串进行反复修改操作时，会产生许多临时对象，这样会浪费内存以及影响垃圾回收的效率，所以更有效率的字符串修改推荐使用StringBuffer和StringBuilder类。<br>效率比较：</p>
<p><img src="image-20210329224849408.png" alt="image-20210329224849408"></p>
<p>StringBuffer和StringBuilder类的区别在于，前者于JDK1.0推出，是线程安全的（同步访问），而后者于JDK1.5推出，非线程安全但执行效率更高。在大多数情况下，建议优先使用StringBuilder类</p>
<h4 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h4><p>创建一个StringBuilder对象需要使用<code>new</code>操作符调用构造方法，构造方法有以下四种：</p>
<ul>
<li><code>StringBuilder()</code>：构造一个不包含任何字符且初始容量为16个字符的StringBuilder对象</li>
<li><code>StringBuilder(CharSequence seq)</code>：以指定字符序列内容构造一个StringBuilder对象，其初始容量为字符序列参数的长度加16</li>
<li><code>StringBuilder(int capacity)</code>：构造一个不包含任何字符且指定初始容量的StringBuilder对象</li>
<li><code>StringBuilder(String str)</code>：以指定字符串构造一个StringBuilder对象，其初始容量为字符串参数的长度加16</li>
</ul>
<p>方法：</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public StringBuilder append(String str)</td>
<td>包括基本数据类型在内共13种重载方法。将指定的数据追加到此序列，其长度会随参数的长度自动增加。 若参数为null ，则将字符<code>null</code>附加到此序列。</td>
</tr>
<tr>
<td>public StringBuilder delete(int start, int end)</td>
<td>删除从start开始到end-1处的字符串，即[start, end)</td>
</tr>
<tr>
<td>public StringBuilder deleteCharAt(int index)</td>
<td>删除指定位置处的字符</td>
</tr>
<tr>
<td>public int indexOf(String str)</td>
<td>返回指定字符第一次出现在此字符串中的位置，没有则返回-1</td>
</tr>
<tr>
<td>public int indexOf(String str, int fromIndex)</td>
<td>同上，但指定开始位置</td>
</tr>
<tr>
<td>public StringBuilder insert(int offset, String str)</td>
<td>包括基本数据类型在内共12种重载方法。将指定的数据按指定的位置插入此字符序列。并将原来在该位置右面的所有字符后移，并将此序列的长度增加参数的长度。 如果参数为null ，则将字符<code>null</code>插入到此序列中</td>
</tr>
<tr>
<td>public int lastIndexOf(String str)</td>
<td>返回指定字符最后一次出现在此字符串中的位置，没有则返回-1</td>
</tr>
<tr>
<td>public int lastIndexOf(String str, int fromIndex)</td>
<td>同上，但指定开始位置</td>
</tr>
<tr>
<td>public StringBuilder replace(int start, int end, String str)</td>
<td>用指定字符串替换此序列指定开始到结束位置的子字符串</td>
</tr>
<tr>
<td>public StringBuilder reverse()</td>
<td>反转字符串</td>
</tr>
</tbody></table>
<h4 id="StringJoiner"><a href="#StringJoiner" class="headerlink" title="StringJoiner"></a>StringJoiner</h4><p>当需要拼接一个带前缀、后缀和使用分隔符分割每个子字符串的字符串时，可以使用StringJoiner。它有两个构造方法：</p>
<ul>
<li><code>StringJoiner(CharSequence delimiter)</code>：以指定分隔符构造一个不带前缀、后缀的StringJoiner对象</li>
<li><code>StringJoiner(CharSequence delimiter,  CharSequence prefix, CharSequence suffix)</code>：以指定分隔符、前缀和后缀构造一个StringJoiner对象</li>
</ul>
<p>以及几个实例方法：</p>
<table>
<thead>
<tr>
<th>方法声明</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>public StringJoiner add(CharSequence newElement)</td>
<td>将给定字符序列值添加为StringJoiner的下一个元素。 如果newElement为null ，则添加字符串<code>null</code></td>
</tr>
<tr>
<td>public int length()</td>
<td>返回此StringJoiner的String表示形式的长度</td>
</tr>
<tr>
<td>public StringJoiner merge(StringJoiner other)</td>
<td>与另一个StringJoiner的元素合并，不使用other的前缀和后缀，但使用other的分隔符作为连接</td>
</tr>
</tbody></table>
<hr>
<p>图：String、StringBuilder、StringBuffer类的继承与接口关系</p>
<p><img src="CharSequence.jpg" alt="CharSequence"></p>
<h3 id="引用类型-包装类"><a href="#引用类型-包装类" class="headerlink" title="引用类型(包装类)"></a>引用类型(包装类)</h3><p>因为面向对象编程语言的特性，所以Java为每个基本数据类型都设计了其对应的引用类型（或者说基础类型的包装类），便于将数据视为对象使用</p>
<table>
<thead>
<tr>
<th align="left">基本数据类型</th>
<th align="left">对应的引用类型</th>
</tr>
</thead>
<tbody><tr>
<td align="left">boolean</td>
<td align="left">java.lang.Boolean</td>
</tr>
<tr>
<td align="left">byte</td>
<td align="left">java.lang.Byte</td>
</tr>
<tr>
<td align="left">short</td>
<td align="left">java.lang.Short</td>
</tr>
<tr>
<td align="left">int</td>
<td align="left">java.lang.Integer</td>
</tr>
<tr>
<td align="left">long</td>
<td align="left">java.lang.Long</td>
</tr>
<tr>
<td align="left">float</td>
<td align="left">java.lang.Float</td>
</tr>
<tr>
<td align="left">double</td>
<td align="left">java.lang.Double</td>
</tr>
<tr>
<td align="left">char</td>
<td align="left">java.lang.Character</td>
</tr>
</tbody></table>
<p>可以给引用对象赋值为<code>null</code>，但不能将基本类型赋值为<code>null</code>。包装类也和<code>String</code>具有相同的设计，被<code>final</code>修饰所以不能被继承，以及内部使用一个<code>private final</code>修饰的对应基本类型的<code>value</code></p>
<p>除了<code>Character</code>只有第一个以外每个包装类都有两个构造方法</p>
<ol>
<li>根据基本类型创建包装类对象</li>
<li>根据字符串创建包装类对象</li>
</ol>
<p>对于第二种构造方法，不同的引用类型有不同的处理方法，所有的整数类型必须是十进制格式，浮点数类型可以使用科学计数法，否则会抛出<code>NumberFormatException</code>异常；<code>Boolean</code>会把除了“true”以外的字符串都转换为<code>false</code></p>
<ul>
<li><p>字段：包装类中也定义了一些静态常量字段，如类型所占二进制位数<code>SIZE</code>，字节数<code>BYTES</code>，最大值<code>MAX_VALUE</code>，最小值<code>MIN_VALUE</code>，浮点数类型还有<code>NaN</code>（非数字），正无穷<code>POSITIVE_INFINITY</code>以及负无穷<code>NEGATIVE_INFINITY</code></p>
</li>
<li><p>方法：整数与浮点数包装类继承自<code>Number</code>类，重写了<code>xxxValue()</code>方法所以可以把包装类对象转换为其它基本类型的数据，实际上还是强制类型转换<br>所有包装类都实现了<code>Comparable</code>接口重写<code>compareTo()</code>方法，用以比较两个包装类的值的大小</p>
</li>
</ul>
<blockquote>
<p>虽然都是用于类型转换的方法，但<code>valueOf(String s)</code>和<code>parseXxx(String s)</code>是有区别的：前者返回包装类型，后者返回基本类型，并且<code>valueOf(String s)</code>会调用<code>parseXxx(String s)</code>方法    所以建议优先使用<code>parseXxx(String s)</code>方法</p>
</blockquote>
<h4 id="自动装箱-amp-拆箱"><a href="#自动装箱-amp-拆箱" class="headerlink" title="自动装箱&amp;拆箱"></a>自动装箱&amp;拆箱</h4><p>从基本类型转换到引用类型这一过程叫“装箱”，反正则是“拆箱”，因为Java编译器自动在基本类型和引用类型之间进行转型，所以被称为自动装箱（Auto Boxing）和自动拆箱（Auto Unboxing）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="number">1</span>; <span class="comment">// Auto Boxing</span></span><br><span class="line"><span class="keyword">int</span> i = a; <span class="comment">// Auto Unboxing</span></span><br></pre></td></tr></table></figure>

<p>在编译后实际执行的字节码中，是严格区分基本类型和引用类型的，所以自动装箱和自动拆箱只会发生在编译过程中。</p>
<p>因为可以给对象赋值为<code>null</code>，而不能给基本类型<code>null</code>值，所以自动拆箱时可能会引发<code>NullPointerException</code></p>
<h4 id="整数缓存机制"><a href="#整数缓存机制" class="headerlink" title="整数缓存机制"></a>整数缓存机制</h4><p>在所有整数引用类型（Byte、Short、Integer、Long）中，都有一个名字带有<code>Cache</code>的私有静态内部类，其用于存储<strong>-127~128</strong>之间的数值，因为java认为这个范围的数据使用是最频繁的，将其生成的包装类对象存储在方法区的常量池中共享可以增加程序执行的效率</p>
<p>如图，若没有缓存机制，则a == b也是false</p>
<p><img src="image-20210401232451010.png" alt="image-20210401232451010"></p>
<blockquote>
<p>缓存以支持<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlL3NwZWNzL2pscy9zZTgvaHRtbC9qbHMtNS5odG1sI2pscy01LjEuNw==">JLS<i class="fa fa-external-link-alt"></i></span>（java语言规范-5.1.7装箱转换）要求的-128到127（含）之间的值的自动装箱的对象标识语义。 首次使用时会初始化缓存。高速缓存的大小可以由-XX:AutoBoxCacheMax=&lt;size&gt;选项控制。 在虚拟机初始化期间，可以在sun.misc.VM类的私有系统属性中设置并保存java.lang.Integer.IntegerCache.high属性。</p>
</blockquote>
<hr>
<p>图：所有包装类的继承与接口关系</p>
<p><img src="Number.png" alt="Number"></p>
<h3 id="数学计算"><a href="#数学计算" class="headerlink" title="数学计算"></a>数学计算</h3><h4 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h4><p>Math类包含了用于执行基本数学运算的一些属性和方法。</p>
<p>Math类是不可被继承的（被<code>final</code>修饰），无法实例化（private的无参构造方法），所以其大量的方法是静态的，直接调用即可</p>
<p>常量有两个，自然对数<code>E</code>和圆周长与直径的比<code>π</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> E = <span class="number">2.7182818284590452354</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.14159265358979323846</span>;</span><br></pre></td></tr></table></figure>

<p>方法示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"-1的绝对值："</span> + Math.abs(-<span class="number">1</span>));</span><br><span class="line">	System.out.println(<span class="string">"2的16次方："</span> + Math.pow(<span class="number">2</span>, <span class="number">16</span>));</span><br><span class="line">	System.out.println(<span class="string">"256的平方根："</span> + Math.sqrt(<span class="number">256</span>));</span><br><span class="line">	System.out.println(<span class="string">"512的立方根："</span> + Math.cbrt(<span class="number">512</span>));</span><br><span class="line">	System.out.println(<span class="string">"1.23向下取整："</span> + Math.floor(<span class="number">1.23</span>));</span><br><span class="line">	System.out.println(<span class="string">"2.22向上取整："</span> + Math.ceil(<span class="number">2.22</span>));</span><br><span class="line">	System.out.println(<span class="string">"3.21四舍五入："</span> + Math.round(<span class="number">3.21</span>));</span><br><span class="line">	System.out.println(<span class="string">"10为底1000的对数："</span> + Math.log10(<span class="number">1000</span>));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">double</span> PI = Math.PI;</span><br><span class="line">	System.out.println(<span class="string">"sin(π/2)="</span> + Math.sin(PI / <span class="number">2</span>));</span><br><span class="line">	System.out.println(<span class="string">"cos(π)="</span> + Math.cos(PI));</span><br><span class="line">	System.out.println(<span class="string">"tan(0)="</span> + Math.tan(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20210402172925472.png" alt="image-20210402172925472"></p>
<blockquote>
<p>默认情况下，Math类的多数方法只是简单地调用StrictMath的等效方法。鼓励代码生成器使用特定于平台的本机库或微处理器指令（如果有）来提供Math方法的高性能实现。这种更高性能的实现仍必须符合Math的规范。</p>
</blockquote>
<p>而<code>StrictMath</code>类的一些方法被声明为<code>native</code>且没有方法体，即方法的实现是由其它语言提供的，这一技术叫JNI（Java Native Interface），通过使用Java本地接口书写程序，可以确保代码在不同的平台上具有相同的计算结果，便于移植。通常情况下使用<code>Math</code>就行了</p>
<h4 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h4><p>Math类仅提供了一个random()方法用以生成[0, 1)之间的随机数，其相当于调用<code>new Random().nextDouble()</code>。而<code>Random</code>类则是专门用于产生随机数的</p>
<p>只有两个构造方法</p>
<ul>
<li>无参构造方法Random()：创建一个新的随机数生成器。该构造方法将使用种子唯一化器与系统纳秒时间值按位异或作为随机数生成器的种子，确保每次调用时都有不同的结果。</li>
<li>Random(long seed)：使用long类型的种子创建一个新的随机数生成器。如果手动指定种子，则随机数生成器对象每次将产生相同的值</li>
</ul>
<p>实例方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line">System.out.println(r.nextInt()); <span class="comment">// 生成一个随机整数</span></span><br><span class="line">System.out.println(r.nextLong()); <span class="comment">// 生成一个长整型随机数</span></span><br><span class="line">System.out.println(r.nextFloat()); <span class="comment">// 生成一个单精度浮点随机数</span></span><br><span class="line">System.out.println(r.nextDouble()); <span class="comment">// 生成一个双精度浮点随机数</span></span><br><span class="line">System.out.println(r.nextBoolean()); <span class="comment">// 生成一个随机布尔值</span></span><br><span class="line">System.out.println(r.nextInt(<span class="number">1000</span>)); <span class="comment">// 生成一个0到指定上限范围的随机整数</span></span><br><span class="line"><span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</span><br><span class="line">r.nextBytes(b); <span class="comment">// 生成一组随机字节并将其放入提供的字节数组中</span></span><br><span class="line"><span class="comment">// 使用流API来生成指定数量与范围的随机数，并使用lambda表达式输出，不指定数量时，数量为Long类型的最大值</span></span><br><span class="line">r.ints(<span class="number">10</span>, <span class="number">0</span>, <span class="number">100</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h4 id="BigInteger"><a href="#BigInteger" class="headerlink" title="BigInteger"></a>BigInteger</h4><p>当需要计算的数据范围超过了long型的最大范围2^63^-1时怎么办呢，java提供了一个大整数类型<code>BigInteger</code>用来处理这种情况，其内部使用了一个<code>int[]</code>用来存放数据，和一个<code>int</code>值来表示符号。因为计算机的内存是有限的，所以<code>BigInteger</code>的实现也要求了其最大范围：当结果超出(-2^Integer.MAX_VALUE^, 2^Integer.MAX_VALUE^)时，调用<code>BigInteger</code>的构造函数和操作都将引发<code>ArithmeticException</code></p>
<p>使用<code>BigInteger</code>做计算的时候只能使用实例方法，不能使用运算符</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	BigInteger b1 = <span class="keyword">new</span> BigInteger(<span class="string">"12345678987654321"</span>);</span><br><span class="line">	BigInteger b2 = <span class="keyword">new</span> BigInteger(<span class="string">"98765432123456789"</span>);</span><br><span class="line">	System.out.println(b1.add(b2)); <span class="comment">// 加</span></span><br><span class="line">	System.out.println(b1.subtract(b2)); <span class="comment">// 减</span></span><br><span class="line">	System.out.println(b1.multiply(b2)); <span class="comment">// 乘</span></span><br><span class="line">	System.out.println(b2.divide(b1)); <span class="comment">// 除</span></span><br><span class="line">	System.out.println(b1.pow(<span class="number">3</span>)); <span class="comment">// 指数值</span></span><br><span class="line">	System.out.println(b2.remainder(b1)); <span class="comment">// 取余</span></span><br><span class="line">	System.out.println(b1.gcd(b2)); <span class="comment">// 求最大公约数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20210403165857438.png" alt="image-20210403165857438"></p>
<h4 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h4><p>和<code>BigInteger</code>类似，因为基本类型的浮点数无法准确的表示其值，所以使用<code>BigDecimal</code>用于处理需要高精度计算的浮点数，内部使用<code>BigInteger</code>值储存数字，<code>int</code>值<code>scale</code>储存小数位数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	BigDecimal b1 = <span class="keyword">new</span> BigDecimal(<span class="string">"123.456789"</span>);</span><br><span class="line">	BigDecimal b2 = <span class="keyword">new</span> BigDecimal(<span class="string">"987654.321"</span>);</span><br><span class="line">	System.out.println(b1.scale()); <span class="comment">// 小数位数，负值表示末尾0的个数</span></span><br><span class="line">	System.out.println(b1.add(b2)); <span class="comment">// 加</span></span><br><span class="line">	System.out.println(b1.subtract(b2)); <span class="comment">// 减</span></span><br><span class="line">	System.out.println(b1.multiply(b2)); <span class="comment">// 乘</span></span><br><span class="line">	<span class="comment">// 除法存在除不尽的情况，此时需要使用第二个参数指定精度，第三个参数指定舍入模式</span></span><br><span class="line">	System.out.println(b2.divide(b1, <span class="number">10</span>, BigDecimal.ROUND_UP));</span><br><span class="line">	<span class="comment">// 或者做除法的同时求余数，返回BigDecimal的数组，分别是商和余数</span></span><br><span class="line">	System.out.println(Arrays.toString(b2.divideAndRemainder(b1)));</span><br><span class="line">	<span class="comment">// 比较值时要使用compareTo()方法，equals()会同时比较小数位数</span></span><br><span class="line">	BigDecimal b3 = <span class="keyword">new</span> BigDecimal(<span class="string">"123.45600"</span>);</span><br><span class="line">	BigDecimal b4 = <span class="keyword">new</span> BigDecimal(<span class="string">"123.456"</span>);</span><br><span class="line">	System.out.println(b3.compareTo(b4));</span><br><span class="line">	System.out.println(b3.equals(b4));</span><br><span class="line">	<span class="comment">// 去掉末尾的0</span></span><br><span class="line">	System.out.println(b3.stripTrailingZeros());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20210403182658582.png" alt="image-20210403182658582"></p>
<p>舍入模式有下面几种</p>
<ul>
<li><code>ROUND_UP</code>：向零远的方向舍入</li>
<li><code>ROUND_DOWN</code>：向零近的方向舍入</li>
<li><code>ROUND_CEILING</code>：向正无穷的方向舍入</li>
<li><code>ROUND_FLOOR</code>：向负无穷的方向舍入</li>
<li><code>ROUND_HALF_UP</code>：四舍五入</li>
<li><code>ROUND_HALF_DOWN</code>：五舍六入</li>
<li><code>ROUND_HALF_EVEN</code>：需要舍入的上一位若是奇数则四舍五入，若是偶数则五舍六入</li>
<li><code>ROUND_UNNECESSARY</code>：不作舍入，如果发生除不尽的情况，则抛出异常<code>ArithmeticException</code></li>
</ul>
<h3 id="时间与日期"><a href="#时间与日期" class="headerlink" title="时间与日期"></a>时间与日期</h3><p>最简单的，获取时间戳：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回当前时间戳（单位：毫秒），即从UTC 1970年1月1日0点0分0秒开始经过的时间。</span></span><br><span class="line"><span class="comment">该值的粒度取决于操作系统测量时间的单位长度，例如许多操作系统会以几十毫秒为单位测量时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">long</span> l = System.currentTimeMillis();</span><br></pre></td></tr></table></figure>

<p>在JavaSE 8之前，日期和时间机制是由<code>java.util.Date</code>，<code>java.util.Calendar</code>和<code>java.util.TimeZone</code>类及其子类提供的。<br>这些类有几个缺点，例如：</p>
<ul>
<li><code>Calendar</code>类不是类型安全的。</li>
<li>因为类是可变的，所以它们不能用于多线程应用程序。</li>
<li>应用程序代码中的错误是常见的，因为月份的编号不常见，并且缺乏类型安全性。</li>
</ul>
<p>额外的，<code>java.sql.Date</code>专门用于数据库的日期对象，其继承自<code>java.util.Date</code>，会自动忽略所有时间相关信息</p>
<p>所以此节将侧重于<code>java.time</code>包下的时间日期类。这是用于表示日期和时间的 API 的核心，它包括日期，时间，日期和时间组合，时区，瞬时，持续时间和时钟的类。这些类是基于ISO-8601中定义的日历系统，并且是不可变的（和<code>String</code>类似）和线程安全的。其分为如下几类：</p>
<ul>
<li>星期和月的枚举：<code>DayOfWeek</code>，<code>Month</code></li>
<li>本地日期和时间：<code>LocalDateTime</code>，<code>LocalDate</code>，<code>LocalTime</code></li>
<li>带时区的日期和时间：<code>ZonedDateTime</code></li>
<li>时刻：<code>Instant</code></li>
<li>时区：<code>ZoneId</code>，<code>ZoneOffset</code></li>
<li>时间间隔：<code>Period</code>，<code>ChronoUnit</code>，<code>Duration</code></li>
</ul>
<blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDE=">ISO-8601<i class="fa fa-external-link-alt"></i></span>日历系统是国际标准化组织的日期和时间的表示方法，全称为“数据存储和交换形式·信息交换·日期和时间的表示方法”。它是当今世界上大部分地区使用的现代民用日历系统。它相当于前公历制度，即所有时间适用于闰年规则。对于现代编写的大多数应用程序，ISO-8601规则是完全合适的。但是对于要求准确历史日期的应用程序来说不合适。</p>
</blockquote>
<p>方法的前缀命名标准：</p>
<table>
<thead>
<tr>
<th>前缀</th>
<th>方法类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>of</code></td>
<td>静态工厂</td>
<td>创建一个实例，其中工厂主要验证输入参数，而不是转换它们。</td>
</tr>
<tr>
<td><code>from</code></td>
<td>静态工厂</td>
<td>将输入参数转换为目标类的实例，这涉及可能从输入中丢失信息。</td>
</tr>
<tr>
<td><code>parse</code></td>
<td>静态工厂</td>
<td>解析输入字符串以生成目标类的实例。</td>
</tr>
<tr>
<td><code>format</code></td>
<td>实例</td>
<td>使用指定的格式化程序格式化时间对象中的值以生成字符串。</td>
</tr>
<tr>
<td><code>get</code></td>
<td>实例</td>
<td>返回目标对象状态的一部分。</td>
</tr>
<tr>
<td><code>is</code></td>
<td>实例</td>
<td>查询目标对象的状态。</td>
</tr>
<tr>
<td><code>with</code></td>
<td>实例</td>
<td>返回目标对象修改后的副本。这与 JavaBean 中的 <code>set</code> 方法不同。</td>
</tr>
<tr>
<td><code>plus</code></td>
<td>实例</td>
<td>返回目标对象的副本，并添加指定的时间量。</td>
</tr>
<tr>
<td><code>minus</code></td>
<td>实例</td>
<td>返回目标对象的副本，并减去指定的时间量。</td>
</tr>
<tr>
<td><code>to</code></td>
<td>实例</td>
<td>将此对象转换为另一种类型。</td>
</tr>
<tr>
<td><code>at</code></td>
<td>实例</td>
<td>将此对象与另一个对象组合。</td>
</tr>
</tbody></table>
<h4 id="常量-1"><a href="#常量-1" class="headerlink" title="常量"></a>常量</h4><p><code>DayOfWeek</code>枚举提供了从<code>MONDAY</code>到<code>SUNDAY</code>共七个用于指定一周中星期几的常量，以及除了枚举类默认方法以外的一些实用方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 计算星期五的3天后是星期几</span></span><br><span class="line">	System.out.println(DayOfWeek.FRIDAY.plus(<span class="number">3</span>));</span><br><span class="line">	<span class="comment">// 计算星期一的5天前是星期几</span></span><br><span class="line">	System.out.println(DayOfWeek.MONDAY.minus(<span class="number">5</span>));</span><br><span class="line">	<span class="comment">// 获取星期几的数字值（1到7）</span></span><br><span class="line">	System.out.println(DayOfWeek.THURSDAY.getValue());</span><br><span class="line">	<span class="comment">// 从数字值获取DayOfWeek的实例，超过范围将抛出DateTimeException</span></span><br><span class="line">	System.out.println(DayOfWeek.of(<span class="number">6</span>));</span><br><span class="line">	<span class="keyword">for</span> (DayOfWeek value : DayOfWeek.values()) &#123; <span class="comment">// 遍历枚举值</span></span><br><span class="line">		<span class="comment">// 返回本地默认语言环境下星期几表示的文本</span></span><br><span class="line">		System.out.printf(<span class="string">"%s\t"</span>, value.getDisplayName(TextStyle.FULL, Locale.getDefault()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20210404172932597.png" alt="image-20210404172932597"></p>
<p><code>Month</code>枚举提供了从<code>JANUARY</code>到<code>DECEMBER</code>用于指定一年中几月的常量，与<code>DayOfWeek</code>枚举类似，<code>Month</code>枚举常量的整数值范围为1到12</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 计算一月的10个月后是几月</span></span><br><span class="line">	System.out.println(Month.JANUARY.plus(<span class="number">10</span>));</span><br><span class="line">	<span class="comment">// 计算二月的5个月前是几月</span></span><br><span class="line">	System.out.println(Month.FEBRUARY.minus(<span class="number">5</span>));</span><br><span class="line">	<span class="comment">// 获取几月的数字值（1到12）</span></span><br><span class="line">	System.out.println(Month.MARCH.getValue());</span><br><span class="line">	<span class="comment">// 从数字值获取Month的实例，超过范围将抛出DateTimeException</span></span><br><span class="line">	System.out.println(Month.of(<span class="number">4</span>));</span><br><span class="line">	<span class="comment">// 获取该月天数的最大值</span></span><br><span class="line">	System.out.println(Month.MAY.maxLength());</span><br><span class="line">	<span class="keyword">for</span> (Month value : Month.values()) &#123; <span class="comment">// 遍历枚举值</span></span><br><span class="line">		<span class="comment">// 返回本地默认语言环境下月份表示的文本</span></span><br><span class="line">		System.out.printf(<span class="string">"%s "</span>, value.getDisplayName(TextStyle.FULL, Locale.getDefault()));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20210404174152009.png" alt="image-20210404174152009"></p>
<h4 id="本地日期"><a href="#本地日期" class="headerlink" title="本地日期"></a>本地日期</h4><p><code>java.time</code>包中的API有4个专门用于处理日期的类，而不用考虑时间或时区。它们分别是：<code>LocalDate</code>、<code>YearMonth</code>、<code>MonthDay</code>和<code>Year</code></p>
<p><code>LocalDate</code>类表示本地日期年月日，用于不需要显示时间的日期</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 从指定年月日创建LocalDate对象</span></span><br><span class="line">	System.out.println(LocalDate.of(<span class="number">2021</span>, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">	<span class="comment">// 从默认时区的系统时钟中获取当前日期。</span></span><br><span class="line">	LocalDate date = LocalDate.now();</span><br><span class="line">	System.out.println(date);</span><br><span class="line">	<span class="comment">// 返回使用时间调节器经过调整后（下个月第一天）的日期</span></span><br><span class="line">	System.out.println(date.with(TemporalAdjusters.firstDayOfNextMonth()));</span><br><span class="line">	<span class="comment">// 或者使用lambda表达式：当年的第100天</span></span><br><span class="line">	System.out.println(date.with(t -&gt; t.with(ChronoField.DAY_OF_YEAR, <span class="number">100</span>)));</span><br><span class="line">	<span class="comment">// 50天后的日期</span></span><br><span class="line">	System.out.println(date.plusDays(<span class="number">50</span>));</span><br><span class="line">	<span class="comment">// 是否为闰年</span></span><br><span class="line">	System.out.println(date.isLeapYear());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20210404231257646.png" alt="image-20210404231257646"></p>
<p><code>YearMonth</code>类表示特定的年和月</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 从指定年月创建YearMonth对象</span></span><br><span class="line">	YearMonth yearMonth = YearMonth.of(<span class="number">2021</span>, <span class="number">1</span>);</span><br><span class="line">	System.out.println(yearMonth);</span><br><span class="line">	<span class="comment">// 返回当月的天数</span></span><br><span class="line">	System.out.println(yearMonth.lengthOfMonth());</span><br><span class="line">	<span class="comment">// 返回当年的天数</span></span><br><span class="line">	System.out.println(yearMonth.lengthOfYear());</span><br><span class="line">	<span class="comment">// 6个月以前的年月</span></span><br><span class="line">	System.out.println(yearMonth.minusMonths(<span class="number">6</span>));</span><br><span class="line">	<span class="comment">// 是否在指定的年月以前</span></span><br><span class="line">	System.out.println(yearMonth.isBefore(YearMonth.now()));</span><br><span class="line">	<span class="comment">// 是否在指定的年月以后</span></span><br><span class="line">	System.out.println(yearMonth.isAfter(YearMonth.of(<span class="number">2021</span>, <span class="number">12</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20210405004318655.png" alt="image-20210405004318655"></p>
<p><code>MonthDay</code>类表示特定的月和日，<code>Year</code>类表示年</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 测试某个月日是否对某年有效</span></span><br><span class="line">	System.out.println(MonthDay.of(Month.FEBRUARY, <span class="number">29</span>).isValidYear(Year.now().getValue()));</span><br><span class="line">	<span class="comment">// 以格式--MM-dd从文本字符串中获取MonthDay的实例</span></span><br><span class="line">	System.out.println(MonthDay.parse(<span class="string">"--11-11"</span>));</span><br><span class="line">	<span class="comment">// 将年份与一年中的第几天结合起来以创建LocalDate</span></span><br><span class="line">	System.out.println(Year.now().atDay(<span class="number">70</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20210405022202184.png" alt="image-20210405022202184"></p>
<h4 id="本地时间"><a href="#本地时间" class="headerlink" title="本地时间"></a>本地时间</h4><p>与<code>LocalDate</code>类类似的<code>LocalTime</code>类仅处理时间，但不存储时区和夏令时信息。使用24小时制，小时数从0到23，分钟数与秒数从0到59，纳秒数从0到999,999,999，但通常纳秒数只有前3位，后面都是0</p>
<p><code>LocalDate</code>与<code>LocalTime</code>组合在一起就是<code>LocalDateTime</code>类了，它用于同时处理日期和时间，也不会储存时区信息。并且根据ISO-8601标准，日期与时间同时显示时，使用<code>T</code>连接</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 以指定小时和分钟数创建LocalTime对象，秒和纳秒数将设置为0</span></span><br><span class="line">	System.out.println(LocalTime.of(<span class="number">6</span>, <span class="number">30</span>));</span><br><span class="line">	<span class="comment">// 计算这个时间是当天的第几秒</span></span><br><span class="line">	System.out.println(LocalTime.now().toSecondOfDay());</span><br><span class="line">	<span class="comment">// 以指定的日期和时间创建LocalDateTime对象</span></span><br><span class="line">	LocalDateTime dateTime = LocalDateTime.of(<span class="number">2021</span>, Month.SEPTEMBER, <span class="number">10</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	System.out.println(dateTime);</span><br><span class="line">	<span class="comment">// 30天后的日期（月份会自动调整）</span></span><br><span class="line">	System.out.println(dateTime.plusDays(<span class="number">30</span>));</span><br><span class="line">	<span class="comment">// 当天是星期几（以枚举字段显示）</span></span><br><span class="line">	System.out.println(dateTime.getDayOfWeek());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20210405172114387.png" alt="image-20210405172114387"></p>
<h4 id="时区和偏移"><a href="#时区和偏移" class="headerlink" title="时区和偏移"></a>时区和偏移</h4><p>时区是使用相同标准时间的地球区域，每个时区可以由标识符描述，通常格式为时区标识符region/city和GMT/UTC时间的偏移量。例：Asia/Shanghai +08:00</p>
<ul>
<li><code>ZoneId</code> 指定时区标识符，并提供在 <code>Instant</code> 和 <code>LocalDateTime</code> 之间进行转换的方法。</li>
<li><code>ZoneOffset</code> 指定从GMT/UTC时区的偏移。</li>
<li><code>ZonedDateTime</code> 处理日期和时间，带有与GMT/UTC时间的偏移量。相当于结合了<code>LocalDateTime</code>类与<code>ZoneId</code>类</li>
<li><code>OffsetDateTime</code> 处理日期和时间，带有与GMT/UTC时间的偏移量，没有时区标识符。相当于结合了<code>LocalDateTime</code>类与<code>ZoneOffset</code>类</li>
<li><code>OffsetTime</code> 处理时间，带有与GMT/UTC时间的偏移量，没有时区标识符。相当于结合了<code>LocalTime</code>类与<code>ZoneOffset</code>类</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 获取系统默认时区</span></span><br><span class="line">	System.out.println(ZoneId.systemDefault());</span><br><span class="line">	<span class="comment">// 使用小时数偏移量获取ZoneOffset</span></span><br><span class="line">	System.out.println(ZoneOffset.ofHours(<span class="number">8</span>));</span><br><span class="line">	<span class="comment">// 使用默认时区从当前系统获取日期时间</span></span><br><span class="line">	System.out.println(ZonedDateTime.now());</span><br><span class="line">	<span class="comment">// 以指定时区表示当前时间</span></span><br><span class="line">	System.out.println(ZonedDateTime.now(ZoneId.of(<span class="string">"America/New_York"</span>)));</span><br><span class="line">	<span class="comment">// 给LocalDateTime添加ZoneId可以转换为ZonedDateTime</span></span><br><span class="line">	<span class="comment">// 以这种方式创建的ZonedDateTime其日期和时间与上面的相同，但附加的时区不同，所以是两个不同的时刻</span></span><br><span class="line">	System.out.println(LocalDateTime.now().atZone(ZoneId.of(<span class="string">"Europe/Paris"</span>)));</span><br><span class="line">	<span class="comment">// 模拟计算2021年4月1日0时0分从上海花费12小时飞往洛杉矶后当地的时间，以及是否为夏令时</span></span><br><span class="line">	ZonedDateTime shanghai = ZonedDateTime.of(<span class="number">2021</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, ZoneId.of(<span class="string">"Asia/Shanghai"</span>));</span><br><span class="line">	System.out.println(shanghai);</span><br><span class="line">	ZonedDateTime losAngeles = shanghai.withZoneSameInstant(ZoneId.of(<span class="string">"America/Los_Angeles"</span>)).plusHours(<span class="number">12</span>);</span><br><span class="line">	System.out.println(losAngeles);</span><br><span class="line">	System.out.println(losAngeles.getZone().getRules().isDaylightSavings(losAngeles.toInstant()));</span><br><span class="line">	<span class="comment">// OffsetDateTime内容：年月日时分秒毫秒偏移</span></span><br><span class="line">	OffsetDateTime offsetDateTime = OffsetDateTime.now();</span><br><span class="line">	System.out.println(offsetDateTime);</span><br><span class="line">	<span class="comment">// 使用OffsetDateTime和TemporalAdjusters查找当月最后一个星期天是几号</span></span><br><span class="line">	System.out.println(offsetDateTime.with(TemporalAdjusters.lastInMonth(DayOfWeek.SUNDAY)).getDayOfMonth());</span><br><span class="line">	<span class="comment">// OffsetTime内容：时分秒毫秒偏移</span></span><br><span class="line">	OffsetTime offsetTime = OffsetTime.now();</span><br><span class="line">	System.out.println(offsetTime);</span><br><span class="line">	<span class="comment">// 丢弃偏移信息转换为本地时间</span></span><br><span class="line">	System.out.println(offsetTime.toLocalTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20210406164009530.png" alt="image-20210406164009530"></p>
<blockquote>
<p>何时使用<code>OffsetDateTime</code>与<code>ZonedDateTime</code>？如果用于编写复杂的软件，根据地理位置为自己的日期和时间计算规则建模，或者将时间戳存储在仅跟踪GMT/UTC时区绝对偏移的数据库中，那么可以选择使用<code>OffsetDateTime</code>。此外，XML和其他网络传输格式将日期时间的格式定义为<code>OffsetDateTime</code>或<code>OffsetTime</code>。</p>
<p>虽然<code>ZonedDateTime</code>、<code>OffsetDateTime</code>与<code>OffsetTime</code>类都带有与GMT/UTC时间的偏移量，但只有<code>ZonedDateTime</code>使用<code>ZoneRules</code>，这是<code>java.time.zone</code>包下的类，其用于确定特定时区的偏移量的变化情况。<code>ZonedDateTime</code>类适用于如夏令时的计算场景，而<code>OffsetDateTime</code>和<code>OffsetTime</code>类没有使用<code>ZoneRules</code>所以不适用。</p>
</blockquote>
<h4 id="时刻与间隔"><a href="#时刻与间隔" class="headerlink" title="时刻与间隔"></a>时刻与间隔</h4><p><code>Instant</code>类表示时间轴上纳秒的开始，可以用于生成表示机器时间的时间戳。返回的值是从1970年1月1日0时0分0秒（GMT）开始计算的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	Instant now = Instant.now();</span><br><span class="line">	System.out.println(now.getEpochSecond()); <span class="comment">// 获取当前时间戳（单位：秒）</span></span><br><span class="line">	System.out.println(now.toEpochMilli()); <span class="comment">// 获取当前时间戳（单位：毫秒）</span></span><br><span class="line">	System.out.println(now.atZone(ZoneId.systemDefault())); <span class="comment">// 附加时区以转换为ZonedDateTime</span></span><br><span class="line">	<span class="comment">// 计算从2000年1月1日0时0分0秒到现在经过了多少秒</span></span><br><span class="line">	System.out.println(Instant.parse(<span class="string">"2000-01-01T00:00:00.00Z"</span>).until(now, ChronoUnit.SECONDS));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20210406203401607.png" alt="image-20210406203401607"></p>
<p><code>Duration</code>用于测量基于秒（或纳秒）为单位的时间量；或者通过<code>Period</code>类来表示基于日期值(年，月，日)定义的时间量，这些时间计算都不会考虑时区或夏令时的影响</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">	<span class="comment">// 计算从6:00到现在经过了多少秒</span></span><br><span class="line">	System.out.println(Duration.between(LocalTime.of(<span class="number">6</span>, <span class="number">0</span>), LocalTime.now()).getSeconds());</span><br><span class="line">	<span class="comment">// 2小时加上30分是多少秒</span></span><br><span class="line">	System.out.println(Duration.ofHours(<span class="number">2</span>).plusMinutes(<span class="number">30</span>).getSeconds());</span><br><span class="line">	<span class="comment">// 现在离1996年9月1日经过了多少年月日，以及多少天</span></span><br><span class="line">	LocalDate birthday = LocalDate.of(<span class="number">1996</span>, <span class="number">9</span>, <span class="number">1</span>);</span><br><span class="line">	LocalDate now = LocalDate.now();</span><br><span class="line">	Period p = Period.between(birthday, now);</span><br><span class="line">	System.out.printf(<span class="string">"%s年%s月%s日\n"</span>, p.getYears(), p.getMonths(), p.getDays());</span><br><span class="line">	System.out.println(ChronoUnit.DAYS.between(birthday, now));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20210406233315537.png" alt="image-20210406233315537"></p>
<h4 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h4><p>使用<code>java.time</code>包下的时间日期类时，若要进行格式化输出，需要使用其相应的格式化程序<code>DateTimeFormatter</code>，此类提供了一组预定义的格式化程序，也可以使用规定好的<span class="exturl" data-url="aHR0cHM6Ly9kb2NzLm9yYWNsZS5jb20vamF2YXNlLzgvZG9jcy9hcGkvamF2YS90aW1lL2Zvcm1hdC9EYXRlVGltZUZvcm1hdHRlci5odG1sI3BhdHRlcm5z">格式化解析参数<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	LocalDateTime now = LocalDateTime.now();</span><br><span class="line">	<span class="comment">// 直接打印时，使用的是ISO 8601标准格式</span></span><br><span class="line">	System.out.println(now);</span><br><span class="line">	<span class="comment">// 使用自定义格式将时间转换为字符串</span></span><br><span class="line">	DateTimeFormatter formatter1 = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss E"</span>);</span><br><span class="line">	System.out.println(now.format(formatter1));</span><br><span class="line">	<span class="comment">// 或者特定于语言环境的日期时间格式</span></span><br><span class="line">	DateTimeFormatter formatter2 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG);</span><br><span class="line">	System.out.println(now.format(formatter2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20210407000024041.png" alt="image-20210407000024041"></p>
<h3 id="数组处理Arrays"><a href="#数组处理Arrays" class="headerlink" title="数组处理Arrays"></a>数组处理Arrays</h3><p><code>Arrays</code>工具类包含了用于操纵数组的各种静态方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 生成10个范围为0到100的随机数组</span></span><br><span class="line">	<span class="keyword">int</span>[] data = <span class="keyword">new</span> Random().ints(<span class="number">5</span>, <span class="number">0</span>, <span class="number">100</span>).toArray();</span><br><span class="line">	<span class="comment">// 输出数组内容的字符串表示形式</span></span><br><span class="line">	printArray(data);</span><br><span class="line">	<span class="comment">// 将指定的数组按升序排序</span></span><br><span class="line">	Arrays.sort(data);printArray(data);</span><br><span class="line">	<span class="comment">// 使用二分法搜索指定值，只能对已升序排序后的数组使用，返回负数表示不存在</span></span><br><span class="line">	System.out.println(Arrays.binarySearch(data, <span class="number">10</span>));</span><br><span class="line">	<span class="comment">// 转换为包装类型的数组</span></span><br><span class="line">	IntStream ints = Arrays.stream(data);</span><br><span class="line">	Integer[] integers = ints.boxed().toArray(Integer[]::<span class="keyword">new</span>);</span><br><span class="line">	<span class="comment">// 然后进行降序排列</span></span><br><span class="line">	Arrays.sort(integers, Comparator.reverseOrder());printArray(integers);</span><br><span class="line">	<span class="comment">// 指定容量复制数组，可以用于对数组进行扩容，扩充元素的初始值视类型而定</span></span><br><span class="line">	data = Arrays.copyOf(data, data.length * <span class="number">2</span>);printArray(data);</span><br><span class="line">	<span class="comment">// 以指定范围[fromIndex, toIndex)用指定值填充数组</span></span><br><span class="line">	Arrays.fill(data, data.length / <span class="number">2</span>, data.length, <span class="number">6</span>);printArray(data);</span><br><span class="line">	<span class="comment">// 判断两个数组是否包含相同顺序的相同元素</span></span><br><span class="line">	System.out.println(Arrays.equals(data, data.clone()));</span><br><span class="line">	<span class="comment">// 将数组转换为list集合</span></span><br><span class="line">	System.out.println(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>).toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printArray</span><span class="params">(<span class="keyword">int</span>[] array)</span> </span>&#123;</span><br><span class="line">	System.out.println(Arrays.toString(array));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20210407232425816.png" alt="image-20210407232425816"></p>
<h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><h4 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h4><p><code>Optional</code>类是一个可以包含null值的容器对象，用于解决空指针异常的问题。<code>Optional</code>构造方法是私有的，所以无法被实例化，通过调用其静态方法获取对象</p>
<ul>
<li><code>empty()</code>：返回一个空的Optional实例</li>
<li><code>of(T value)</code>：T为泛型。以指定值返回一个Optional实例，如果传入值为<code>null</code>会抛出<code>NullPointerException</code></li>
<li><code>ofNullable(T value)</code>：同上，但允许<code>null</code>值</li>
</ul>
<p>实例方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	Integer i = <span class="number">1</span>;</span><br><span class="line">	Optional&lt;Integer&gt; oi = Optional.of(i);</span><br><span class="line">	Optional&lt;Object&gt; oo = Optional.empty();</span><br><span class="line">	<span class="comment">// 如果此Optional存在值，则返回该值，否则抛出NoSuchElementException</span></span><br><span class="line">	System.out.println(oi.get());</span><br><span class="line">	<span class="comment">// 如果存在值，则返回true，否则返回false</span></span><br><span class="line">	System.out.println(oo.isPresent());</span><br><span class="line">	<span class="comment">// 如果存在值，则返回该值，否则返回参数值</span></span><br><span class="line">	System.out.println(oo.orElse(<span class="string">"null"</span>));</span><br><span class="line">	<span class="comment">// 以下为函数式编程方法</span></span><br><span class="line">	oi.ifPresent(System.out::println); <span class="comment">// 如果存在值，则使用该值调用指定操作，否则不执行任何操作</span></span><br><span class="line">	<span class="comment">// filter：如果存在值，则将这个值与给定的判断式匹配然后返回一个描述这个值的Optional，否则返回一个空的Optional</span></span><br><span class="line">	<span class="comment">// orElseGet：如果存在值则返回值，否则调用表达式方法并返回调用的结果。</span></span><br><span class="line">	System.out.println(oi.filter(x -&gt; x == <span class="number">0</span>).orElseGet(() -&gt; Integer.valueOf(<span class="string">"0"</span>)));</span><br><span class="line">	<span class="comment">// map：如果存在值，则将提供的映射函数应用于该值。如果映射函数的返回值不为null，则返回包含返回值的Optional，否则返回空的Optional</span></span><br><span class="line">	<span class="comment">// orElseThrow：如果存在值则返回值，否则抛出提供的异常</span></span><br><span class="line">	System.out.println(oi.map(Object::toString).orElseThrow(NullPointerException::<span class="keyword">new</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20210409195044213.png" alt="image-20210409195044213"></p>
<h4 id="UUID"><a href="#UUID" class="headerlink" title="UUID"></a>UUID</h4><p><span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9VVUlELzU5MjEyNjY=">UUID<i class="fa fa-external-link-alt"></i></span>（Universally Unique Identifier，通用唯一标识码）是用于计算机体系中识别信息数目的一组8bit128个数字所构成的标识符。GUID（Globally Unique Identifier）全球唯一标识码则特指微软对UUID标准的实现。</p>
<p>java中的UUID类仅有一个公共的构造方法：<code>UUID(long mostSigBits, long leastSigBits)</code>，但需要指定最高64位有效值和最低64位有效值，所以为了便于使用，有三种静态方法来创建UUID：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	List&lt;UUID&gt; uuids = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">	uuids.add(UUID.randomUUID());<span class="comment">// 随机获取</span></span><br><span class="line">	uuids.add(UUID.fromString(UUID.randomUUID().toString())); <span class="comment">// 根据指定标准UUID字符串创建UUID对象</span></span><br><span class="line">	uuids.add(UUID.nameUUIDFromBytes(<span class="string">"uuid char array"</span>.getBytes())); <span class="comment">// 根据指定的字节数组创建UUID</span></span><br><span class="line">	uuids.forEach(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20210410172020926.png" alt="image-20210410172020926"></p>
<p>实例方法：</p>
<ul>
<li><code>variant()</code>：变体，占1、2或3bit，在标准表示形式的第四组第一个表示。共有4种<ul>
<li>0，二进制0，保留，用于向后兼容已经过时的NCS（1988年开发的Apollo网络计算系统）</li>
<li>2，二进制10，由<span class="exturl" data-url="aHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzQxMjIudHh0">IETF RFC 4122<i class="fa fa-external-link-alt"></i></span>(Leach-Salz)定义。使用大端序作为二进制存储与传输方式。此类使用的就是这个</li>
<li>6，二进制110，保留，由微软向后兼容。使用小端序作为二进制存储与传输方式</li>
<li>7，二进制111，保留，便于以后定义</li>
</ul>
</li>
<li><code>version()</code>：版本，在标准表示形式的第三组第一个表示。对于第二和第三种变体，标准中定义了五种版本，java中只有前四种<ul>
<li>1，基于时间戳、随机数和机器MAC地址的UUID</li>
<li>2，基于DEC安全的UUID</li>
<li>3，基于名称的UUID。通过计算MD5散列值和命名空间（namespace）标识符获得</li>
<li>4，使用随机性或伪随机性生成</li>
<li>5，同3，但是使用SHA1算法</li>
</ul>
</li>
<li><code>clockSequence()</code>：UUID的时钟序列值，<strong>仅版本1可用</strong></li>
<li><code>timestamp()</code>：UUID的时间戳，以100纳秒为单位，自1582年10月15日起计算，<strong>仅版本1可用</strong></li>
<li><code>getMostSignificantBits()</code>：返回最高64位有效值</li>
<li><code>getLeastSignificantBits()</code>：返回最低64位有效值</li>
<li><code>toString()</code>：UUID的标准字符串表示形式</li>
</ul>
<h4 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h4><blockquote>
<p>Base64是一种基于64个可打印字符来表示二进制数据的表示方法。由于log<del>2</del>64=6，所以每6个比特为一个单元，对应某个可打印字符。3个字节相当于24个比特，对应于4个Base64单元，即3个字节可由4个可打印字符来表示。在Base64中的可打印字符包括字母A-Z、a-z、数字0-9，共62个字符，此外两个可打印符号在不同的系统中而不同。一些如uuencode的其他编码方法，和之后BinHex的版本使用不同的64字符集来代表6个二进制数字，但是不被称为Base64。</p>
<p>Base64常用于在通常处理文本数据的场合，表示、传输、存储一些二进制数据，包括MIME的电子邮件及XML的一些复杂数据。</p>
</blockquote>
<p>Java的<code>Base64</code>类则提供了三种不同方式的编码器和解码器实现：</p>
<ul>
<li>基本的：使用<span class="exturl" data-url="aHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzQ2NDgudHh0">RFC 4648<i class="fa fa-external-link-alt"></i></span>中表1和<span class="exturl" data-url="aHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzIwNDUudHh0">RFC 2045<i class="fa fa-external-link-alt"></i></span>指定的base64字符进行编码和解码操作。编码器不添加任何换行符，解码器拒绝base64以外的字符数据。</li>
<li>URL和文件名安全的：使用<span class="exturl" data-url="aHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzQ2NDgudHh0">RFC 4648<i class="fa fa-external-link-alt"></i></span>中表2指定的base64字符进行编码和解码操作。其它同上</li>
<li><span class="exturl" data-url="aHR0cHM6Ly96aC53aWtpcGVkaWEub3JnL3dpa2kvJUU1JUE0JTlBJUU3JTk0JUE4JUU5JTgwJTk0JUU0JUJBJTkyJUU4JTgxJUFGJUU3JUI2JUIyJUU5JTgzJUI1JUU0JUJCJUI2JUU2JTkzJUI0JUU1JUIxJTk1">MIME<i class="fa fa-external-link-alt"></i></span>：使用<span class="exturl" data-url="aHR0cHM6Ly93d3cuaWV0Zi5vcmcvcmZjL3JmYzIwNDUudHh0">RFC 2045<i class="fa fa-external-link-alt"></i></span>中表1指定的base64字符进行编码和解码操作。编码后的每行不超过76个字符，并且使用<code>\r\n</code>作为行分隔符。编码输出最后没有行分隔符</li>
</ul>
<p>通常使用下面几个静态方法来获取编码器和解码器：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 编码器，依次对应上述三种类型</span></span><br><span class="line">Base64.Encoder encoder = Base64.getEncoder();</span><br><span class="line">Base64.Encoder urlEncoder = Base64.getUrlEncoder();</span><br><span class="line">Base64.Encoder mimeEncoder = Base64.getMimeEncoder();</span><br><span class="line"><span class="comment">// 解码器，依次对应上述三种类型</span></span><br><span class="line">Base64.Decoder decoder = Base64.getDecoder();</span><br><span class="line">Base64.Decoder urlDecoder = Base64.getUrlDecoder();</span><br><span class="line">Base64.Decoder mimeDecoder = Base64.getMimeDecoder();</span><br><span class="line"><span class="comment">// MIME类型编码器，可以通过参数指定每行的长度及行的分隔符</span></span><br><span class="line">Base64.Encoder me = Base64.getMimeEncoder(<span class="number">64</span>, <span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="string">'\n'</span>&#125;);</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] uuid = UUID.randomUUID().toString().getBytes(StandardCharsets.UTF_8);</span><br><span class="line">System.out.println(<span class="string">"原字符串："</span> + <span class="keyword">new</span> String(uuid, StandardCharsets.UTF_8));</span><br><span class="line">System.out.println(<span class="string">"base64基本编码："</span> + encoder.encodeToString(uuid));</span><br><span class="line">System.out.println(<span class="string">"base64url编码："</span> + urlEncoder.encodeToString(uuid));</span><br><span class="line"></span><br><span class="line">StringJoiner sj = <span class="keyword">new</span> StringJoiner(<span class="string">","</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">    sj.add(UUID.randomUUID().toString());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">"原字符串："</span> + sj.toString());</span><br><span class="line"><span class="keyword">byte</span>[] bytes = sj.toString().getBytes(StandardCharsets.UTF_8);</span><br><span class="line">System.out.println(<span class="string">"base64mime编码："</span> + mimeEncoder.encodeToString(bytes));</span><br></pre></td></tr></table></figure>

<p><img src="image-20210411025947381.png" alt="image-20210411025947381"></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>VoidSoul
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://voidsoul0.github.io/java/java-base/" title="Java基础整理与查漏补缺">https://voidsoul0.github.io/java/java-base/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</span> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/software/portable-software/" rel="prev" title="各种开发软件便携版的获取、制作与配置">
      <i class="fa fa-chevron-left"></i> 各种开发软件便携版的获取、制作与配置
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



        </div>
        
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user-circle"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">VoidSoul</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">94k</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>

<script src="/js/utils.js"></script>


<script src="/js/next-boot.js"></script>


  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>




  
<script src="/js/local-search.js"></script>













  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    new Valine(Object.assign({
      el  : '#valine-comments',
      path: location.pathname,
    }, {"enable":true,"appId":"RnUFFHSLABgtaVxM0cDTfSqS-gzGzoHsz","appKey":"u4oJCfVFNQBlzzt2miaLqkoV","placeholder":"(」・ω・)」唔 -- (/・ω・)/喵---(」・ω・)」唔 --(/・ω・)/ 喵---","avatar":"mm","meta":["nick","mail","link"],"pageSize":10,"language":"zh-cn","visitor":false,"comment_count":false,"recordIP":true,"serverURLs":null}
    ));
  }, window.Valine);
});
</script>

</body>
</html>
